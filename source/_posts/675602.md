---
layout: post
title: '银行家算法'
date: 2006-04-24 20:14
comments: true
tags: ['算法','delete','iostream']
categories:
- code
---


```cplusplus

#include<iostream>
using namespace std;
int **allocate,*total,**need,*require;
int num_process,num_resource;
bool isDeadLock(int c=0);
bool findFinish();
void printALL(int**b_allocate,int** b_need,int* b_total);
bool isAllFinish(int**);
int main()
{
 cin >> num_process >> num_resource;
 need = new int* [num_process]; 
 allocate = new int*[num_process];
 total = new int [num_resource];
 require = new int[num_resource];
 int i,q;
 for(i=0;i<num_process;i++)
 {
  need[i] = new int[num_resource];
  allocate[i] = new int[num_resource];
 }
 //define the number of each resource
 for(i=0;i<num_resource;i++)
  cin >> total[i];
 for(i=0;i<num_resource;i++)
  cout <<  total[i];
 //define the processes get how much resource
 for(i=0;i<num_process;i++)
  for(q=0;q<num_resource;q++)
  cin >> allocate[i][q];
 //cheak the resource has enough to allocate
 for(i=0;i<num_resource;i++)
  for(q=0;q<num_process;q++)
  { if(total[i]-allocate[q][i]>=0)
    total[i]-=allocate[q][i];
   else 
   {
    cerr << "error!";
    return 1;
   }
  }

 //define how much resources will each process still need to get to finish itself now
 for(i=0;i<num_process;i++)
  for(q=0;q<num_resource;q++)
   cin >> need[i][q];
 printALL(allocate,need,total);
 //cheak the allocate is deadlock or not
 if(isDeadLock())
 {
  cerr << "dead Lock" ;
  return 1;
 }
 else
  cout << "System is safe"<<endl;
 //auto test
 int test;
 cout << "choose 1:auto test, else:custom test. ";
 cin >> test;
 if(test==1)
 {
  isDeadLock(test);
 }
 //custom test
 else
 {
  while(isAllFinish(need))
  {
   for(i=0;i<num_process;i++)
   {
    cout << i<<": require how much resource?"<<endl;
    for(q=0;q<num_resource;q++)
     cin >> require[q];
    //determine the data of require is right
    for(q=0;q<num_resource;q++)
    { 
     if(total[q] < require[q] || need[i][q] < require[q])
     { 
      cout << "error data information"<<endl;
      i--;
      break;
     }
     total[q]-=require[q];
     need[i][q]-=require[q];
     allocate[i][q]+=require[q];     
    }
    if(isDeadLock(1))
    {
     i--;
     cout << "System is in deadlock state"<<endl;
    }
    else
     cout << "System is safe......"<<endl;
   }
  }
 }
 return 0;
}
//if all the processes are finished,then return true; 
bool isAllFinish(int** b_need)
{
 int i,q;
 for(i=0;i<num_process;i++)
  for(q=0;q<num_resource;q++)
  {
   if(b_need[i][q]!=0)
    return false;
  }
 return true;
}
//if it is deadlock ,then return true;else return false
bool isDeadLock(int c)//c is a flag to show the information or not.
{
 int **backup_allocate,**backup_need,*backup_total;
 backup_need = new int* [num_process]; 
 backup_allocate = new int*[num_process];
 backup_total = new int[num_resource];
 int i,q;
 for(i=0;i<num_process;i++)
 {
  backup_need[i] = new int[num_resource];
  backup_allocate[i] = new int[num_resource]; 
 }
 for(i=0;i<num_process;i++)
  for(q=0;q<num_resource;q++)
  {
   backup_need[i][q] = need[i][q];
   backup_allocate[i][q] = allocate[i][q];
  }
 for(i=0;i<num_resource;i++)
  backup_total[i] = total[i];
// return findFinish();
 if(c!=0)
 printALL(backup_allocate,backup_need,backup_total);
 int flag=0,count=0;
 while(!isAllFinish(backup_need))
 {
  count=0;
  for(i=0;i<num_process;i++)
  { for(q=0;q<num_resource;q++)
   {
    if(backup_need[i][q]>backup_total[q])
    { 
     flag = 0;
     break;
    }
     flag=1;
   }
  // find a finishing process and collect the resource
   if(flag==1)
   {
    count++;
    for(q=0;q<num_resource;q++)
    {
     backup_total[q]+=backup_allocate[i][q];
     backup_allocate[i][q]=0;
     backup_need[i][q]=0;
    }
    
   }
   printALL(backup_allocate,backup_need,backup_total);
  }
//  if(c!=0)
//   printALL(backup_allocate,backup_need,backup_total);
//if no process is finished,it means no resource is collect once.Then the deadlock appears.
  if(count==0)
  {
   delete []backup_total;
   for(i=0;i<num_process;i++)
   { delete[]backup_allocate[i];
    delete[]backup_need[i];
   }
   delete []backup_allocate;
   delete []backup_need;
   return true;
  }
 }

 return false;
}
void printALL(int**b_allocate,int** b_need,int* b_total)
{
 int i,q;
 cout << "Allocate need"<<endl;
 for(i=0;i<num_process;i++)
 { 
  for(q=0;q<num_resource;q++)
  {
   cout << b_allocate[i][q]<<"  ";
  }
  cout << " ";
  for(q=0;q<num_resource;q++)
   cout << b_need[i][q]<<"  ";
  cout << endl;
 }
 cout << "total"<<endl;
 for(i=0;i<num_resource;i++)
  cout << b_total[i]<<"  ";
 cout << endl;
}

/*
bool findFinish()
{
 int i,q,flag=0,count=0;
 for(i=0;i<num_process;i++)
 { for(q=0;q<num_resource;q++)
  {
   if(need[i][q]>total[q])
   { 
    flag = 0;
    break;
   }
    flag=1;
  }
  if(flag==1)
  {
   count++;
   for(q=0;q<num_resource;q++)
   {
    total[q]+=allocate[i][q];
    allocate[i][q]=0;
   }
  }
 }
 if(count!=0)
  return true;
 return false;
}*/
```
