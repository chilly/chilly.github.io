<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.ico">
  <link rel="mask-icon" href="/icon.svg" color="#222">
  <meta name="google-site-verification" content="hcdiytqUGPoTW0eAaN6TWAmRfiv7IWFIIc9DKNr7Eno">
  <meta name="yandex-verification" content="eb8f01295fdccb3d">
  <meta name="baidu-site-verification" content="QoJxa8tZnO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Times+New+Roman:300,300italic,400,400italic,700,700italic%7CRaleway:300,300italic,400,400italic,700,700italic%7COswald:300,300italic,400,400italic,700,700italic%7CWork+Sans:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chillyc.info","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":20,"unescape":false,"preload":false}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/config.min.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="帐前卒专栏">
<meta property="og:url" content="http://chillyc.info/page/34/">
<meta property="og:site_name" content="帐前卒专栏">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="帐前卒">
<meta property="article:tag" content="有意思的代码，有意思的架构, 有趣的小说, 好看的故事, code, software, articles, novel, architect">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://chillyc.info/page/34/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/34/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>帐前卒专栏 - code, software architect, articles and novels.<br/>代码，软件架构，博客和小说</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="帐前卒专栏" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <!-- Global site tag (gtag.js) - Google Analytics start -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-11621532-3"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6565392687771630"
     crossorigin="anonymous"></script>
<script>
  window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-11621532-3');
</script>
 <!-- Global site tag (gtag.js) - Google Analytics end -->
  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">帐前卒专栏</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">code, software architect, articles and novels.<br/>代码，软件架构，博客和小说</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-feeds"><a href="/rss2.xml" rel="section"><i class="fa fa-feed fa-fw"></i>feeds</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="帐前卒"
      src="/icon.svg">
  <p class="site-author-name" itemprop="name">帐前卒</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">797</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">757</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoaWxseQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chilly"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9jY3R0XzE=" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;cctt_1"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLW5kLzQuMC8="><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/big/by_nc_nd.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/11/27/4887019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/11/27/4887019/" class="post-title-link" itemprop="url">ubuntu9.04 安装Openoffice , 数学公式, 字体等</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-11-27 11:02:00" itemprop="dateCreated datePublished" datetime="2009-11-27T11:02:00+08:00">2009-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>893</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先要有openoffice.在system-&gt;administration-&gt;synaptic package Manager中输入openoffice,<br />
<span class="exturl" data-url="aHR0cDovL3huLS1vcGVub2ZmaWNlLXV0MnAyODdhMGthMDE5bGlvMWVvbDVkLm9yZw==">并选中列出的openoffice.org<i class="fa fa-external-link-alt"></i></span>。然后再输入openoffice math, 选中texlive-math-extra。然后点击apply开始安装。</p>
<p>再启动openoffice之后，在Insert-&gt;object-&gt;formula中就可以创建公式了。点击一个，在下方可以编辑“&lt;?&gt;”来替代文中的方块。</p>
<p>添加字体转载自：<span class="exturl" data-url="aHR0cDovL3d3dy5md29sZi5jb20vYmxvZy9wb3N0LzE3MA==">http://www.fwolf.com/blog/post/170<i class="fa fa-external-link-alt"></i></span></p>
<p>windows的字体一般存放在c:/windows/fonts目录下，我拷贝到linux下的字体有：</p>
<p>simfang.ttf 仿宋体 simhei.ttf 黑体 simkai.ttf 楷体 simsun.ttf 宋体和新宋体，原文件名simsun.ttc<br />
tahoma.ttf tahoma字体 tahomabd.ttf tahoma字体的粗体形式 verdana.ttf verdana字体<br />
verdanab.ttf verdana字体的粗体形式 verdanai.ttf verdana字体的斜体形式 verdanaz.ttf<br />
verdana字体的粗体＋斜体形式</p>
<p>拷贝过来的字体文件放在了/home/fwolf/tools/fonts目录下。</p>
<p>** 二、将字体加入到linux的可使用字体中 **</p>
<p>首先把字体文件链接到存放字体的目录中</p>
<p>cd /usr/share/fonts ln -s /home/fwolf/tools/fonts xpfonts cd xpfonts<br />
mkfontscale mkfontdir</p>
<p>这样作和把字体拷贝到/usr/share/fonts的一个目录下的效果是一样的。后面的两个mkfont命令是生成xpfonts目录下所包含的字体的索引信息<br />
。然后运行fc-cache命令更新字体缓存：</p>
<p>fc-cache</p>
<p>在openoffice中其中仿宋体的字体名是FangSong_GB2312，黑体是SimHei，楷体是KaiTi_GB2312，宋体是SimSun</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/11/16/4818068/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/11/16/4818068/" class="post-title-link" itemprop="url">I Will Try Google Doc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-11-16 20:49:00" itemprop="dateCreated datePublished" datetime="2009-11-16T20:49:00+08:00">2009-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>17</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>I will try google doc</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/11/14/4811198/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/11/14/4811198/" class="post-title-link" itemprop="url">关于户口和三方协议的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-11-14 19:43:00" itemprop="dateCreated datePublished" datetime="2009-11-14T19:43:00+08:00">2009-11-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转自北邮，北邮又可能转自清华。所以我写转自<span class="exturl" data-url="aHR0cDovL3F1bi5xcS5jb20vYWlyLyM4ODM0MjQ1Mi9iYnMvdmlldy9jZC8yL3RkLzg=">http://qun.qq.com/air/#88342452/bbs/view/cd/2/td/8<i class="fa fa-external-link-alt"></i></span></p>
<p>最近补了一下课。首先企业和学生申报户口的大概流程是这样的：</p>
<p>1，单位申报本年度的户口指标。各区申报截止时间不同，基本走人事局的在12月前就申报完成，基本是在11月15日前。</p>
<p>2，人事部门审批单位申报的指标。人事局的基本都在12月底到1月中会下来，也有很牛的企业会更早的；人事部的2月中下来。会严格控制数量。需要注意：指标的多少基本<br />
只跟公司的规模，行业，性质，纳税等等方面有关，跟学生材料没有丝毫关系。</p>
<p>3，单位、学生正式申报。此时人事部门根据之前审批给单位的户口名额，再综合考虑学生的情况（专业是否紧俏，是否对口，是否双外）和单位的情况（牛不牛）进行审批。事<br />
业单位部委都通过人事部申请指标，审批也是走人事部，相对好批；私企，民企和外企等通过人事局申请指标，到时也是走人事局审批材料，相对不好批。</p>
<p>关于三方的作用</p>
<p>三方主要两个作用，一是规范公司和学生的行为。二是户口、转档用。而实际上第二个作用才是主要的作用，第一个作用是可以通过双方协议（因为学生还不能签劳动合同，所以<br />
学生和单位自己签订非劳动合同形式的协议）达到的，而第二个是无法代替的。</p>
<p>** 因此，如果单位不能解决户口，实际上就没有权利签三方，如果签了，只会让学生浪费申报户口的机会！！  ** 这一点一定要注意！因为如果我们愿意去这个单位A，但又想解决户口，唯一的办法就是挂到其他可以解决户口的单位B，比如自己买户口。这时候，单位B必须拿到你的三方才能给你申报户口。而且不仅如此，就算不找其他在京单位解决户口了，档案户口回家乡，家乡单位也需要和你签署三方呀。更大的麻烦是：提出不给你办户口却要和你签三方的要求的单位，往往是对应届毕业生就业制度一无所知，所以千万不要给他们，一旦给了，等你发现需要新三方来纠正这件事情的时候学校往往会要求你拿回原三方，而你去向单位要的时候，他们因为不懂，往往以为你要违约，说什么都不给你，那时候就只剩一个字了：“晕！！”</p>
<p>单位A想给你申报户口，但不能保证申报成功，怎么办？</p>
<p>这时候一定要注意让单位填三方时在审批通过之前不要在三方中填写“单位信息”，这是因为：审批时虽然需要用到三方协议，但此时除个人及学校信息栏外，其他栏，包括单位<br />
信息栏，空白即可，也即由单位上报的三方中其实不需要包括它自己单位的信息。一般正规的做法是，是公司先把你的其他审批材料上报给北京人事局或国家人事部，等“户口接<br />
收函”快下来前才会把三方中的“单位信息栏”填完，然后盖上章交给人事局或人事部，这时才完成户口审批。而如果审批失败，则单位可以将三方立刻退给你，你可以立刻拿这<br />
张三方找其他单位申报（比如买户口），而不必去学校重新换一张三方。学校换一张三方有什么坏处？有些学校不乐意学生换，所以会为难我们，清华的倒不存在这个问题，但没<br />
必要多此一举，而且正规的公司应该按规定主动在审批结果没下来之前不在单位信息栏中填写信息。</p>
<p>另外有一点，如果我们在单位A申报不成功，那么之后想再申报户口就会很困难，因为在人事局已经有记录了，其他单位再申报你的信息时可以被认为是“多头申报”（即同一个<br />
人在不同的单位进行申报，即便不是同时申报的，这是严厉禁止的）。目前了解到考国家公务员和到基层单位就业可能不存在这个问题。因此，如果一个单位本身很难解决户口，<br />
我们不如一开始就跟单位说好只签双方的协议，而把宝贵的三方留作自己解决户口时才用（比如买户口）。</p>
<p>还有一种情况是单位承诺如果单位的在A城市的分公司A不能解决户口的话，可以在B城市的分公司B给予解决。这时候单位信息栏也很明显不能填，因为分公司 A一旦发现户<br />
口审批没有成功，就可以立刻拿着这份空白三方再去分公司B申报。此时因为A、B两个公司不在同一个城市，不是由同一个人事局审批，也就不存在多头申报的可能了。</p>
<p>单位不能解决户口，也不想买户口，又想在单位工作，怎么办？</p>
<p>应该办理灵活就业手续，领取回生源地人事局的二分报到证，同时将户档落回生源地。这样的好处是：首先，你在国家规定的派遣时间内领取报到证，避免将来因种种原因错过报<br />
到证办理期限，失去“干部”身份（如果晚了就会落到劳动局，就是工人身份了）；其次，你将来有可能按“人才引进”的方式将户口调入实际工作单位所在地，但是需要注意的<br />
是，实际上从06年开始，人才引进在实际操作中已经不审批了，所以如果单位给你人才引进的承诺，基本上是口头支票。<br />
关于违约</p>
<p>虽然叫三方，你和企业签了之后实际上就生效了，即便学校没签，想违约也要交违约金（其实这时候不能交违约，因为学校没签三方也就没生效，但是是不是叫违约并不重要，关<br />
键是能否领回单位手里的三方），因为不交的话单位不会交回三方你也就无法领到新的三方。</p>
<p>另外，如果在上报就业方案后（6月份）再违约，就属于改派，原则上不能再在北京或上海等不便落户的地方落户，学校一般也不喜欢改派。</p>
<p>前面说了其实三方的规范公司和学生行为的作用实际上是次要的作用，但又往往很多企业很在乎，而且很多企业要求学生赶紧交三方，不管是有指标的企业还是最终没有指标的企<br />
业，这一是因为公司的HR根本不懂户籍相关的政策，二是因为HR把三方的用处认为是劳动合同签订之前的补充了，想用三方来约束我们违约的情况。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/11/13/4807117/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/11/13/4807117/" class="post-title-link" itemprop="url">模2除法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-11-13 14:09:00" itemprop="dateCreated datePublished" datetime="2009-11-13T14:09:00+08:00">2009-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>446</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这或许是一个简单的问题，但是我早就忘记咋解了。</p>
<p>关于一个二进制数1111000 除以1101，模2除法的商为1011，余数为111.这个结果不同于十进制除法。所以特记下。具体步骤如下：</p>
<p>#第一步 1111000 1101 0010000 ----余数，商为1，只要第一位非0商就是1<br />
#第二步，每步移一位，当起始位为0时，除以0；为1时除以除数。 010000 0000 010000 ----余数，商为0，只要第一位是0商就是0 #第三步<br />
10000 1101 01010 -----余数，商为1，这里的余数你猜出，其实就是对应位异或 #第四步 1010 1101 0111<br />
------余数，商为1，如果位数比除数还小，不再继续运算 #最终余数为111，商为1011</p>
<p>模2除法，参考了下网络资源。最后得到的结论。不知道是正确与否。</p>
<p>模2除法可以用在CRC冗余校验上。K,H均为2进制数，K向左移R，然后K除以H。模2除得到的余数在放到R位中。例如：K=1111,H=1101,R=3，移位<br />
之后得1111000，最后CRC=1111111。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/11/09/4788611/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/11/09/4788611/" class="post-title-link" itemprop="url">ubuntu9.04 (Server版) 配置Xen虚拟机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-11-09 10:20:00" itemprop="dateCreated datePublished" datetime="2009-11-09T10:20:00+08:00">2009-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载自：<span class="exturl" data-url="aHR0cDovL3dlbGxzLm9zYWxsLmNvbS9ibG9nL2luZGV4LnBocD91aWQ9MSZtPWNvbnRlbnQmcD0xNDM0I2FydGljbGVfY29udGU=">http://wells.osall.com/blog/index.php?uid=1&amp;m=content&amp;p=1434#article_conte<i class="fa fa-external-link-alt"></i></span><br />
nt.php%3Fid%3D1434%26uid%3D1%26dt%3DY:pane:N;</p>
<h1 id="bitime-咀嚼时光"><a class="markdownIt-Anchor" href="#bitime-咀嚼时光"></a> BITimE // 咀嚼时光</h1>
<p>前两天买了个Seagate的320G的2.5寸SATA硬盘，真便宜，300多元，差不多每G一元钱了。于是就把原来移动硬盘里的160G的硬盘装在那台ATOM小<br />
PC上了。如果大家还没忘记的话，应该还记得 <a target="_blank" rel="noopener" href="http://wells.osall.com/blog/index.php?uid=1&amp;m=content&amp;p=1417"> 我的那个ATOM小PC里面是用的8G的CF转IDE作为硬盘<br />
</a><br />
的。现在突然存储设备容量大了20倍，那就让它干更多的活吧。兔子老是跟我说他在他的服务器上装了 <a target="_blank" rel="noopener" href="http://blog.lalacafe.com/category/xen/"> n多虚拟机<br />
</a> ，充分利用硬件资源，那我也来试一下吧。</p>
<p>Linux上有很多虚拟机软件， <span class="exturl" data-url="aHR0cDovL3d3dy54ZW4ub3JnLw=="> XEN <i class="fa fa-external-link-alt"></i></span> 、 [ KVM ](http://www.linux-<br />
<span class="exturl" data-url="aHR0cDovL2t2bS5vcmcvcGFnZS9NYWluX1BhZ2U=">kvm.org/page/Main_Page<i class="fa fa-external-link-alt"></i></span>) 、 <span class="exturl" data-url="aHR0cDovL3d3dy52bXdhcmUuY29tLw=="> VMWare <i class="fa fa-external-link-alt"></i></span> 、 <a target="_blank" rel="noopener" href="http://www.virtualbox.org/"> VirtualBox<br />
</a><br />
，从开源角度和性能角度来考量，当然选XEN啦。XEN性能非常优异，虚拟的主机的性能几乎和原生主机一致，如果主机硬件支持 <a target="_blank" rel="noopener" href="http://www.intel.com/technology/virtualization/"> VT (intel)<br />
</a> 或者 [ SVM (AMD) ](<span class="exturl" data-url="aHR0cDovL3d3dw==">http://www<i class="fa fa-external-link-alt"></i></span><br />
.amd.com/us/products/technologies/virtualization/Pages/virtualization.aspx)<br />
的技术的话，则可以虚拟任何能在x86架构上运行的操作系统。可惜我的ATOM 330<br />
CPU不支持VT技术，因此只能玩半虚拟模式，虚拟出内核支持XEN的操作系统了。</p>
<p>换上新硬盘，首先就是安装新的操作系统。我一直用惯了Ubuntu，因此就安装了 <a target="_blank" rel="noopener" href="http://www.ubuntu.com/products/WhatIsUbuntu/serveredition"> Ubuntu 9.04 Server Edition 64位<br />
</a><br />
版本。安装OS的过程就不多说了，直接说XEN的安装配置吧。</p>
<p>在XEN虚拟机环境上第一个被启动的操作系统被称为Domain-0，而之后启动的其他虚拟操作系统则被称为Domain-U，每一个Domain 就是一台虚拟机<br />
。Domain-0除了可以运行应用程序外，还担负着XEN的控制功能，所以也被称为XEN Hypervisor。在Domain-<br />
0上启动了XEN服务后，最重要的一个进程就是xend，这就是XEN的服务进程。</p>
<p>我们新安装的操作系统如果没有安装XEN软件，则就相当于普通的一个单机使用。如果安装了XEN软件，并且以XEN化的内核启动，则这个操作系统环<br />
境就变成了Domain-0，而后在这个环境下安装的其他操作系统则就是Domain-U了，都可以通过Domain-0来进行控制。</p>
<p>![虚拟机架构](<span class="exturl" data-url="aHR0cDovL3AuYmxvZy5jc2RuLm5ldC9pbWFnZXMvcF9ibG9nX2NzZG5fbmV0L2NjdHRfMS9FbnRyeUltYWdlcy8yMDA5">http://p.blog.csdn.net/images/p_blog_csdn_net/cctt_1/EntryImages/2009<i class="fa fa-external-link-alt"></i></span><br />
1109/hypervisor_01.png)</p>
<p>要安装并使用XEN，首先更新软件源的信息。</p>
<h1 id="sudo-apt-get-update"><a class="markdownIt-Anchor" href="#sudo-apt-get-update"></a> sudo apt-get update</h1>
<p>然后安装xen服务器软件和工具。</p>
<h1 id="sudo-apt-get-install-ubuntu-xen-server-sudo-apt-get-install-ubuntu-xen-"><a class="markdownIt-Anchor" href="#sudo-apt-get-install-ubuntu-xen-server-sudo-apt-get-install-ubuntu-xen-"></a> sudo apt-get install ubuntu-xen-server # sudo apt-get install ubuntu-xen-</h1>
<p>desktop<br />
这时候我们去/boot目录看，可以看到一个xen3.3.gz文件，但是没有供操作系统使用的XEN化的内核，因此此时的操作系统还不是Doamin-0。我找了好<br />
久都没找到现成的XEN化内核，于是就只能根据XEN手册自己编译一个内核了。</p>
<p>下载安装最新的kernel文件。</p>
<h1 id="sudo-apt-get-install-linux-image-server-linux-server"><a class="markdownIt-Anchor" href="#sudo-apt-get-install-linux-image-server-linux-server"></a> sudo apt-get install linux-image-server linux-server</h1>
<p>安装编译所需要的一些工具包。</p>
<h1 id="sudo-apt-get-install-build-essential-libncurses5-dev-gawk-mercurial"><a class="markdownIt-Anchor" href="#sudo-apt-get-install-build-essential-libncurses5-dev-gawk-mercurial"></a> sudo apt-get install build-essential libncurses5-dev gawk mercurial</h1>
<p>接下来下载XEN所提供的XEN化的内核的源代码。</p>
<h1 id="mkdir-p-~buildlinux-2627-xen-cd-usrsrc-sudo-hg-clone"><a class="markdownIt-Anchor" href="#mkdir-p-~buildlinux-2627-xen-cd-usrsrc-sudo-hg-clone"></a> mkdir -p ~/build/linux-2.6.27-xen # cd /usr/src/ # sudo hg clone</h1>
<p><span class="exturl" data-url="aHR0cDovL3hlbmJpdHMueGVuc291cmNlLmNvbS9leHQvbGludXgtMi42LjI3LXhlbi5oZw==">http://xenbits.xensource.com/ext/linux-2.6.27-xen.hg<i class="fa fa-external-link-alt"></i></span><br />
配置内核选项。</p>
<h1 id="cd-usrsrclinux-2627-xenhg-sudo-make-o~buildlinux-2627-xen"><a class="markdownIt-Anchor" href="#cd-usrsrclinux-2627-xenhg-sudo-make-o~buildlinux-2627-xen"></a> cd /usr/src/linux-2.6.27-xen.hg # sudo make O=~/build/linux-2.6.27-xen/</h1>
<p>menuconfig<br />
出现内核参数的配置菜单后，根据如下的选项修改配置。</p>
<p>1。General setup —&gt; Choose SLAB allocator (SLUB (Unqueued Allocator)) —&gt;<br />
(X) SLAB</p>
<p>2。Processor type and features —&gt; Subarchitecture Type (PC-compatible) —&gt;<br />
(X) Enable Xen compatible kernel</p>
<p>3。</p>
<p>Bus options (PCI etc.) —&gt; [<em>] PCI support [</em>] Xen PCI Frontend [ ] Xen PCI<br />
Frontend Debugging (NEW)<br />
4。将 <M> 802.1d Ethernet Bridging 修改为 &lt;*&gt; 802.1d Ethernet Bridging:</p>
<p>Networking support —&gt; Networking options —&gt; &lt;*&gt; 802.1d Ethernet Bridging</p>
<p>5。关闭 10000 Mbit Ethernet 支持（否则可能编译失败）：</p>
<p>Device Drivers —&gt; [*] Network device support —&gt; [ ] Ethernet (10000 Mbit)<br />
—&gt;</p>
<p>6。在 XEN 选项区中，按照下面选择选项（确认选择 Xen version compatibility (3.0.4 and later) 来取代原来的<br />
Xen version compatibility (3.0.2 and later)）：<br />
Device Drivers —&gt; XEN —&gt; [<em>] Privileged Guest (domain 0) &lt;</em>&gt; Backend<br />
driver support (NEW) &lt;<em>&gt; Block-device backend driver (NEW) &lt;</em>&gt; Block-device<br />
tap backend driver (NEW) &lt;<em>&gt; Network-device backend driver (NEW) (8) Maximum<br />
simultaneous transmit requests (as a power of 2) (NEW) [ ] Pipelined<br />
transmitter (DANGEROUS) (NEW) &lt; &gt; Network-device loopback driver (NEW) &lt;</em>&gt;<br />
PCI-device backend driver (NEW) PCI Backend Mode (Virtual PCI) —&gt; [ ] PCI<br />
Backend Debugging (NEW) &lt; &gt; TPM-device backend driver (NEW) <M> SCSI backend<br />
driver (NEW) <M> Block-device frontend driver <M> Network-device frontend<br />
driver <M> Network-device frontend driver acceleration for Solarflare NICs<br />
(NEW) <M> SCSI frontend driver (NEW) &lt;<em>&gt; User-space granted page access driver<br />
(NEW) &lt;</em>&gt; Framebuffer-device frontend driver (NEW) &lt;<em>&gt; Keyboard-device<br />
frontend driver (NEW) [</em>] Disable serial port drivers (NEW) &lt;*&gt; Export Xen<br />
attributes in sysfs (NEW) (256) Number of guest devices (NEW) Xen version<br />
compatibility (3.0.4 and later) —&gt;<br />
ESC退出并保存完配置后就可以开始编译内核了。</p>
<p>可能这里要先 make mrproper</p>
<h1 id="sudo-make-o~buildlinux-2627-xen"><a class="markdownIt-Anchor" href="#sudo-make-o~buildlinux-2627-xen"></a> sudo make O=~/build/linux-2.6.27-xen/</h1>
<h1 id="sudo-make-o~buildlinux-2627-xen-modules_install-install"><a class="markdownIt-Anchor" href="#sudo-make-o~buildlinux-2627-xen-modules_install-install"></a> sudo make O=~/build/linux-2.6.27-xen/ modules_install install</h1>
<p>通过漫长的等待（我的Atom 330<br />
CPU花了大约3个小时），终于编译完内核了。编译安装完成后，去/boot目录检查，应该可以看到生成了支持xen的2.6.27.5的内核了。</p>
<h1 id="ls-l-boot"><a class="markdownIt-Anchor" href="#ls-l-boot"></a> ls -l /boot</h1>
<p>total 72697<br />
-rw-r–r-- 1 root root   525592 2009-04-17 12:05 abi-2.6.28-11-server<br />
-rw-r–r-- 1 root root   524602 2009-07-25 11:14 abi-2.6.28-14-server<br />
-rw-r–r-- 1 root root    87448 2009-08-13 19:50 config-2.6.27.5<br />
-rw-r–r-- 1 root root    90587 2009-04-17 12:05 config-2.6.28-11-server<br />
-rw-r–r-- 1 root root    90560 2009-07-25 11:14 config-2.6.28-14-server<br />
drwxr-xr-x 2 root root     1024 2009-08-13 20:04 grub<br />
-rw-r–r-- 1 root root  8259056 2009-08-14 03:31 initrd.img-2.6.28-11-server<br />
-rw-r–r-- 1 root root  8272673 2009-08-13 15:02 initrd.img-2.6.28-14-server<br />
drwxr-xr-x 2 root root    12288 2009-08-14 03:17 lost+found<br />
-rw-r–r-- 1 root root   128796 2009-03-28 04:12 memtest86+.bin<br />
-rw-r–r-- 1 root root  1651431 2009-08-13 19:50 System.map-2.6.27.5<br />
-rw-r–r-- 1 root root  1871187 2009-04-17 12:05 System.map-2.6.28-11-server<br />
-rw-r–r-- 1 root root  1863183 2009-07-25 11:14 System.map-2.6.28-14-server<br />
-rw-r–r-- 1 root root     1169 2009-04-17 12:09 vmcoreinfo-2.6.28-11-server<br />
-rw-r–r-- 1 root root     1169 2009-07-25 11:16 vmcoreinfo-2.6.28-14-server<br />
-rw-r–r-- 1 root root  3145318 2009-08-13 19:50 vmlinuz-2.6.27.5<br />
-rw-r–r-- 1 root root  3520832 2009-04-17 12:05 vmlinuz-2.6.28-11-server<br />
-rw-r–r-- 1 root root  3510496 2009-07-25 11:14 vmlinuz-2.6.28-14-server<br />
-rw-r–r-- 1 root root   470084 2009-06-18 16:16 xen-3.3.gz</p>
<p>内核有了，但是还没有initrd.img也就是启动时所需的ramdisk文件，手动来生成一个。</p>
<h1 id="sudo-depmod-26275"><a class="markdownIt-Anchor" href="#sudo-depmod-26275"></a> sudo depmod 2.6.27.5</h1>
<h1 id="sudo-update-initramfs-c-k-26275"><a class="markdownIt-Anchor" href="#sudo-update-initramfs-c-k-26275"></a> sudo update-initramfs -c -k 2.6.27.5</h1>
<p>更新grub引导程序。</p>
<h1 id="update-grub"><a class="markdownIt-Anchor" href="#update-grub"></a> update-grub</h1>
<p>现在XEN的环境基本上都建好了，我们需要来修改一下配置文件了。</p>
<p>XEN服务的配置文件都在/etc/xen目录下。XEN服务的主配置文件是 /etc/xen/xend-<br />
config.sxp。打开这个文件，我们要确认的是XEN虚拟服务器的网络连接方式，这是相当重要的。我选择了桥接模式， 也就是说，Domain-<br />
U虚拟机和Domain-0在同一子网，用Domain-0的物理网卡来进行桥接到虚拟机的虚拟网卡。</p>
<h1 id="sudo-vi-etcxenxend-configsxp"><a class="markdownIt-Anchor" href="#sudo-vi-etcxenxend-configsxp"></a> sudo vi /etc/xen/xend-config.sxp</h1>
<p>确认网络部分是这样配置的：<br />
(network-script network-bridge)<br />
下一步要根据你的习惯来修改。你喜欢将虚拟机安装在哪里？是用一个镜像文件来虚拟成磁盘，还是将一个LVM逻辑卷虚拟成磁盘，或者干脆就是将物理磁盘给虚拟机使用？</p>
<p>对于后两种选择，你可以跳过这一步。但如果你选择了在现有的文件系统中建立一个镜像文件来虚拟成一个虚拟机的物理磁盘，那就要按照下面修改默认配置了。</p>
<p>由于镜像文件在加载的时候是作为回圈设备（loop device），因此要将操作系统的默认最大回圈设备数量调大，以免出现不必要的问题。</p>
<h1 id="sudo-vi-etcmodules"><a class="markdownIt-Anchor" href="#sudo-vi-etcmodules"></a> sudo vi /etc/modules</h1>
<p>将loop这一行修改为：<br />
loop max_loop=64<br />
好啦，重启主机，进入Domain-0的世界！！！</p>
<h1 id="sudo-shutdown-r-now"><a class="markdownIt-Anchor" href="#sudo-shutdown-r-now"></a> sudo shutdown -r now</h1>
<p>重启完成后检查一下kernel版本，是不是XEN化的那个2.6.27.5？</p>
<h1 id="uname-r"><a class="markdownIt-Anchor" href="#uname-r"></a> uname -r</h1>
<p>2.6.27.5<br />
现在可以使用XEN的管理命令xm，来看看虚拟机运行状况啦！</p>
<h1 id="sudo-xm-list"><a class="markdownIt-Anchor" href="#sudo-xm-list"></a> sudo xm list</h1>
<p>Name                                        ID   Mem VCPUs      State<br />
Time(s)<br />
Domain-0                                     0  1473     4     r-----    479.8<br />
哈哈，可以看到Domain-0正常运行！！！你可以使用xm help来学习如何通过xm来管理虚拟机。</p>
<p>在State列，看到Domain-0是r的状态，也就是说，这个Domain正在运行中，并有任务在该Domain上运行。虚拟机还有如下几种状态：</p>
<ul>
<li>r ：该domain正在消耗CPU资源，任务运行中；</li>
<li>b ：该domain正被暂时搁置(blockded)，一般来说是因为这个domain在闲置中，等待输入或输出(I/O)；</li>
<li>p ：该domain处于暂停状态，通常是因为管理员使用 xm pause 暂停了这个domain。当domain至于暂停状态时，Xen的管理器将不会处理这个domain的任何动作；</li>
<li>s ：该domain正在关机；</li>
<li>c ：该domain已经crash了，但是没有关机。一般来说是因为domain的配置文件没有设置 on_crash 动作所致；</li>
<li>d ：该domain正在死机中，一般来说是因为这个domain无法正确 shutdown/crashed 之故。</li>
</ul>
<p>先到这里吧，总算是把XEN安装上了，而且也把Domain-0给顺利启动了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/10/30/4748865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/10/30/4748865/" class="post-title-link" itemprop="url">ubuntu9.04 Mpich2 1.2版本 搭建集群种种问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-10-30 16:53:00" itemprop="dateCreated datePublished" datetime="2009-10-30T16:53:00+08:00">2009-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-07 12:48:27" itemprop="dateModified" datetime="2023-10-07T12:48:27+08:00">2023-10-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>找到很多网上的文档，也是一步一步按照上面所做，可是就是有太多的问题。写一篇自己的搭建过程和错误产生的原因。</p>
<p>开始我找了两台服务器，上面装的是Asianux的操作系统，因为含有rsh服务。所以会报出：</p>
<p>connect to address XXXX: Connection refused<br />
Trying krb4 rlogin…<br />
connect to address XXXX: Connection refused<br />
trying normal rlogin (/usr/bin/rlogin)</p>
<p>这个问题解决方案有多种，不过最简单的一种是在配置时：./configure添加参数 -rsh=ssh如下：</p>
<p>./configure -rsh=ssh</p>
<p>后来我有了多台机器，并且因为要搭建云的缘故，所以只有重新来过。首先找来4台机器，一个switch,这4台机器都是内网中的。我可以通过远程ssh登录上去。然后<br />
装系统ubuntu9.04,这里要注意的是，用户名必须一致，并且hostname设置为node1,node2,node3,node4.如果你不这样做，后面会<br />
出来非常多的问题，我稍后会一一解决。这里先介绍一下一般流程。</p>
<p>1。然后找一个好源，再使用apt-get更新.具体步骤详见: <a target="_blank" rel="noopener" href="http://blog.csdn.net/cctt_1/archive/2009/10/14/4667460.aspx"><br />
http://blog.csdn.net/cctt_1/archive/2009/10/14/4667460.aspx<br />
</a></p>
<p>然后sudo apt-get install ssh,这一步是下载并安装ssh.</p>
<p>2。然后下载 [ mpich2-1.2 ](<span class="exturl" data-url="aHR0cDovL3d3dy5tY3MuYW5sLmdvdi9yZXNlYXJjaC9wcm9qZWN0cy9tcGljaDIvZG93bmxvYWQ=">http://www.mcs.anl.gov/research/projects/mpich2/download<i class="fa fa-external-link-alt"></i></span><br />
s/tarballs/1.2/mpich2-1.2.tar.gz) ,当然你还可以下载一份 <a href="ftp://ftp.mcs.anl.gov/pub/mpi/mpich2-doc-install.pdf"> mpich2的安装文档<br />
</a><br />
。都下载到server（主节点）上,然后执行下面的操作:</p>
<p>tar xzvf mpich2-1.2.tar.gz或者使用命令gunzip -c mpich2.tar.gz | tar xf -(后者我没有试过)</p>
<p>3。然后mkdir mpich2在进入刚才解压的目录,执行配置文件./configure -prefix=…/mpich2 -rsh=ssh这里的-<br />
prefix是你要安装到哪里（就是刚才的mkdir的目录）。之后make一下，然后make install 一下，看看报的错误，我当时好像缺少g++和gcc<br />
，所以最好先apt-get 这两个东东。如果还是报错，就使用sudo ./configure -prefix=…/mpich2 -rsh=ssh,<br />
sudo make , sudo make install.</p>
<p>4。之后把mpich2/bin这个文件路径放入到/etc/profile的最后一行,这样写，这里/home/you/是你的用户主目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH＝<span class="variable">$PATH</span>:/home/you/mpich2/bin</span><br></pre></td></tr></table></figure>
<p>然后log out再log in,如果不想这样，也可以export PATH=$PATH:/home/you/mpich2/bin临时做一下。然后echo $PATH，看看有没有添加成功。再下一步which mpd,看看有没有找到相应的路径。</p>
<p>5。然后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span> <span class="built_in">touch</span> .mpd.conf <span class="comment">#创建一个文件 chmod 600 .mpd.conf #设置权限</span></span><br></pre></td></tr></table></figure>
<p>6。下一步vi .mpd.conf,添加一行MPD_SECRETWORD=abcd,这里的abcd是自己写的，你可以变动。这一步是以后使用mpd命令必须加入<br />
的，主要是为了机器间的通信。</p>
<p>7。然后vi mpd.hosts,写入你的那几台机器的hostname,记住一行一个,如下:</p>
<p>node1 node2 node3 node4</p>
<p>这其实是你要让那些主机运行mpi的程序。</p>
<p>8。然后你在server（主节点）运行一下以下命令。</p>
<p>mpd &amp; #启动一个mpd mpdtrace #查看哪些主机加入到ring中 mpdallexit#退出</p>
<p>这几个命令执行一下，如果没发生什么错误，就ok.</p>
<p>9。之后修改/etc/hosts，添加几行ip和hostname的对应关系。在127.0.0.1<br />
localhost之后添加几行(这里假设server节点为node1当然，你可以改动): 192.168.12.111 node1 server<br />
#个人认为这里的server加不加都可以就只是一个名字 192.168.12.112 node2 192.168.12.113 node3<br />
192.168.12.114 node4</p>
<p>10。然后配置ssh自动登录，如何配置请看blog: <a target="_blank" rel="noopener" href="http://blog.csdn.net/cctt_1/archive/2009/10/14/4667604.aspx"><br />
http://blog.csdn.net/cctt_1/archive/2009/10/14/4667604.aspx<br />
</a><br />
.配置完毕后，在server节点依次输入:ssh node1 date，ssh node2 date, ssh node3 date , ssh node4<br />
date.看看有没有返回date,主要是为了检测自己能否使用ssh登录到自己或其他节点。其他节点按照此法依次检测一下。如果不需要输入密码，并返回了date,<br />
则ssh配置成功。</p>
<p>11。之后把你的mpich2/bin这个目录(./configure时的目录)打包 tar cvf bin.tar<br />
mpich2/bin,然后将包发送到其他节点：node2,node3…。可以使用scp命令如下:</p>
<p>scp bin.tar you@node2:bin.tar</p>
<p>12。使用ssh登录到其他节点上，并解压bin.tar,然后按照第4步添加此路径并检查一下。</p>
<p>13。在各个节点上重做一下5，6，8，9，10，第7步可以不做。</p>
<p>14。回到server,使用如下两个命令: mpd &amp; ,  mpdtrace -l，这就会得到<hostname>_<port><br />
(ip),检查下这三项是不是对的<br />
。hostname应该是自己的node1,port是一个随机分配的，ip是hostname对应的ip（和/etc/hosts中的一样）</p>
<p>15。ssh到其他节点，然后输入mpd -h <hostname> -p <port><br />
&amp;，这里的<hostname>和<port>是14步中server的。如果执行这步没有错误，输入mpdtrace,就能看到node1,node2…</p>
<p>16。配置完成。集群已经搭建成功。以后启动的时候，只需要在server上执行mpdboot -n <number> -f<br />
mpd.hosts,这里的<number>是你想启动的mpi程序数(会分配到不同的节点上)，mpd.hosts是第七步创建的文件。</p>
<p>种种问题～～～～～～～:</p>
<p>1.没有使用相同的用户名(ubuntu上root用户你是不可能知道密码的)，所以只有开始安装Ubuntu时的用户。你要做的是必须在所有节点都添加一个相同的用<br />
户。因为mpich2在后续使用mpd －h <host> -p<br />
<port>&amp;命令加入到已存在的ring中时使用的是相同的用户名。并且如果你的用户名不同，ssh node2, ssh<br />
node3,是不可能通过的，除非你使用了ssh you@node3,但mpd不会这样作，除非你要修改它的源码。要建立用户可以使用我下面编写的小脚本，并且加入<br />
的用户获得了和你安装用户一样的权限(除了自己组权限)。记得要使用sudo命令来执行并且chmod +x XXXscript。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh newone=&quot;mpich&quot; #这里添加的用户为mpich,你也可以改动。 hostloc=&quot;/etc/hosts&quot; # create</span></span><br><span class="line">a new member and input the password useradd -m <span class="variable">$newone</span> passwd <span class="variable">$newone</span> <span class="comment"># get</span></span><br><span class="line">the admin member <span class="built_in">who</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> &gt;&gt; tmpuser user=`<span class="built_in">head</span> -n 1 tmpuser` <span class="comment">#</span></span><br><span class="line">get the admin member<span class="string">&#x27;s groups and remove the self group groupinfo=`groups</span></span><br><span class="line"><span class="string">$user | awk &#x27;</span>&#123;<span class="built_in">print</span>&#125;<span class="string">&#x27;| sed &#x27;</span>s/<span class="string">&#x27;$user&#x27;</span>//<span class="string">&#x27;` # copy the groups to the new member</span></span><br><span class="line"><span class="string">for i in $groupinfo;do gpasswd -a $newone $i done echo `groups $newone`</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>2.hostname并不是node1,node2,node3,而是其他的名字。这里必须要改，否则mpd -h <host> -p<br />
<port>&amp;命令时会有rsh connect refused 或者timeout的情况。并且mpdtrace<br />
-l时，会有ip和hostname不对应的情况。如下是更改方法:先在/etc/hosts中删除原来的hostname,然后 vi<br />
/etc/hostname改成你想要的，注意必须顶行写。然后使用sudo<br />
/etc/init.d/hostname来重新得到hostname,logout一下再login就会改掉。</p>
<p>3. rsh krb4 krb5问题，就使用./configure -rsh=ssh就可以解决</p>
<p>4. ./configure时有时会让你添加–disable-c++,你需要升级你的g<ins>了，sudo apt-get install g</ins></p>
<p>5.make时文件冲突，只要使用sudo make即可</p>
<p>6.创建了新用户，记得使用新用户来执行ssh-keygen。ssh和用户是相关的。</p>
<p>7.清看清我的blog题目，如果你的不是mpich2-1.2可能搭建起来与此过程不同。mpich-<br />
1中mpd是非安装的。我之前曾照网上的文档安装就是走不通。原因是版本不对。那个官方文档是mpich2-1.0.6的…好像也稍有不同。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/10/29/4743979/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/10/29/4743979/" class="post-title-link" itemprop="url">Linux Bash Command Bash脚本命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-10-29 16:53:00" itemprop="dateCreated datePublished" datetime="2009-10-29T16:53:00+08:00">2009-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>13 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转自：<span class="exturl" data-url="aHR0cDovL3NzNjQuY29tL2Jhc2gv">http://ss64.com/bash/<i class="fa fa-external-link-alt"></i></span></p>
<p>好不容易才找到…</p>
<pre><code>  [alias](http://ss64.com/bash/alias.html)
    Create an alias  

  apropos  Search Help manual pages (man -k)  

  [apt-get](http://www.debian.org/doc/manuals/apt-howto/ch-apt-get.en.html)
  Search for and install software packages (Debian)  

  [aspell](http://aspell.net/)
   Spell Checker  

  [awk](http://ss64.com/bash/awk.html)
      Find and Replace text, database sort/validate/index  

b  

  bash     GNU Bourne-Again SHell   

  [bc](http://ss64.com/bash/bc.html)
       Arbitrary precision calculator language   

  [bg](http://ss64.com/bash/bg.html)
       Send to background  

  [break](http://ss64.com/bash/break.html)
    Exit from a loop  

  [builtin](http://ss64.com/bash/builtin.html)
  Run a shell builtin  

  [bzip2](http://www.bzip.org/)
    Compress or decompress named file(s)  

c  

  [cal](http://ss64.com/bash/cal.html)
      Display a calendar  

  [case](http://ss64.com/bash/case.html)
     Conditionally perform a command  

  [cat](http://ss64.com/bash/cat.html)
      Display the contents of a file  

  [cd](http://ss64.com/bash/cd.html)
       Change Directory  

  [cfdisk](http://ss64.com/bash/cfdisk.html)
   Partition table manipulator for Linux  

  [chgrp](http://ss64.com/bash/chgrp.html)
    Change group ownership  

  [chmod](http://ss64.com/bash/chmod.html)
    Change access permissions  

  [chown](http://ss64.com/bash/chown.html)
    Change file owner and group  

  [chroot](http://ss64.com/bash/chroot.html)
   Run a command with a different root directory  

  [chkconfig](http://ss64.com/bash/chkconfig.html)
 System services (runlevel)  

  [cksum](http://ss64.com/bash/cksum.html)
    Print CRC checksum and byte counts  

  clear    Clear terminal screen  

  [cmp](http://ss64.com/bash/cmp.html)
      Compare two files  

  [comm](http://ss64.com/bash/comm.html)
     Compare two sorted files line by line  

  [command](http://ss64.com/bash/command.html)
  Run a command - ignoring shell functions  

  [continue](http://ss64.com/bash/continue.html)
 Resume the next iteration of a loop  

  [cp](http://ss64.com/bash/cp.html)
       Copy one or more files to another location  

  [cron](http://ss64.com/bash/cron.html)
     Daemon to execute scheduled commands  

  [crontab](http://ss64.com/bash/crontab.html)
  Schedule a command to run at a later time  

  [csplit](http://ss64.com/bash/csplit.html)
   Split a file into context-determined pieces  

  [cut](http://ss64.com/bash/cut.html)
      Divide a file into several parts  

d  

  [date](http://ss64.com/bash/date.html)
     Display or change the date &amp; time  

  [dc](http://ss64.com/bash/dc.html)
       Desk Calculator  

  [dd](http://ss64.com/bash/dd.html)
       Convert and copy a file, write disk headers, boot records  

  [ddrescue](http://ss64.com/bash/ddrescue.html)
 Data recovery tool  

  [declare](http://ss64.com/bash/declare.html)
  Declare variables and give them attributes  

  [df](http://ss64.com/bash/df.html)
       Display free disk space  

  [diff](http://ss64.com/bash/diff.html)
     Display the differences between two files  

  [diff3](http://ss64.com/bash/diff3.html)
    Show differences among three files  

  [dig](http://ss64.com/bash/dig.html)
      DNS lookup  

  [dir](http://ss64.com/bash/dir.html)
      Briefly list directory contents  

  [dircolors](http://ss64.com/bash/dircolours.html)
 Colour setup for `ls'  

  [dirname](http://ss64.com/bash/dirname.html)
  Convert a full pathname to just a path  

  [dirs](http://ss64.com/bash/dirs.html)
     Display list of remembered directories  

  [dmesg](http://ss64.com/bash/dmesg.html)
    Print kernel &amp; driver messages   

  [du](http://ss64.com/bash/du.html)
       Estimate file space usage  

e  

  [echo](http://ss64.com/bash/echo.html)
     Display message on screen  

  [egrep](http://ss64.com/bash/egrep.html)
    Search file(s) for lines that match an extended expression  

  [eject](http://ss64.com/bash/eject.html)
    Eject removable media  

  [enable](http://ss64.com/bash/enable.html)
   Enable and disable builtin shell commands  

  [env](http://ss64.com/bash/env.html)
      Environment variables  

  ethtool  Ethernet card settings  

  [eval](http://ss64.com/bash/eval.html)
     Evaluate several commands/arguments  

  [exec](http://ss64.com/bash/exec.html)
     Execute a command  

  [exit](http://ss64.com/bash/exit.html)
     Exit the shell  

  [expect](http://en.wikipedia.org/wiki/Expect)
   Automate arbitrary applications accessed over a terminal  

  [expand](http://ss64.com/bash/expand.html)
   Convert tabs to spaces  

  [export](http://ss64.com/bash/export.html)
   Set an environment variable  

  [expr](http://ss64.com/bash/expr.html)
     Evaluate expressions  

f  

  [false](http://ss64.com/bash/false.html)
    Do nothing, unsuccessfully  

  [fdformat](http://ss64.com/bash/fdformat.html)
 Low-level format a floppy disk  

  [fdisk](http://ss64.com/bash/fdisk.html)
    Partition table manipulator for Linux  

  [fg](http://ss64.com/bash/fg.html)
       Send job to foreground   

  [fgrep](http://ss64.com/bash/fgrep.html)
    Search file(s) for lines that match a fixed string  

  file     Determine file type  

  [find](http://ss64.com/bash/find.html)
     Search for files that meet a desired criteria  

  [fmt](http://ss64.com/bash/fmt.html)
      Reformat paragraph text  

  [fold](http://ss64.com/bash/fold.html)
     Wrap text to fit a specified width.  

  [for](http://ss64.com/bash/for.html)
      Expand words
, and execute commands
  format   Format disks or tapes  

  free     Display memory usage  

  [fsck](http://ss64.com/bash/fsck.html)
     File system consistency check and repair  

  ftp      File Transfer Protocol  

  [function](http://ss64.com/bash/function.html)
 Define Function Macros  

  [fuser](http://ss64.com/bash/fuser.html)
    Identify/kill the process that is accessing a file  

g  

  [gawk](http://ss64.com/bash/awk.html)
     Find and Replace text within file(s)  

  [getopts](http://ss64.com/bash/getopts.html)
  Parse positional parameters  

  [grep](http://ss64.com/bash/grep.html)
     Search file(s) for lines that match a given pattern  

  [groups](http://ss64.com/bash/groups.html)
   Print group names a user is in  

  [gzip](http://ss64.com/bash/gzip.html)
     Compress or decompress named file(s)  

h  

  [hash](http://ss64.com/bash/hash.html)
     Remember the full pathname of a name argument  

  [head](http://ss64.com/bash/head.html)
     Output the first part of file(s)  

  [history](http://ss64.com/bash/history.html)
  Command History  

  [hostname](http://ss64.com/bash/hostname.html)
 Print or set system name  

i  

  [id](http://ss64.com/bash/id.html)
       Print user and group id's  

  [if](http://ss64.com/bash/if.html)
       Conditionally perform a command  

  [ifconfig](http://ss64.com/bash/ifconfig.html)
 Configure a network interface  

  [ifdown](http://ss64.com/bash/ifup.html)
   Stop a network interface   

  [ifup](http://ss64.com/bash/ifup.html)
     Start a network interface up  

  [import](http://ss64.com/bash/import.html)
   Capture an X server screen and save the image to file  

  [install](http://ss64.com/bash/install.html)
  Copy files and set attributes  

j  

  [join](http://ss64.com/bash/join.html)
     Join lines on a common field  

k  

  [kill](http://ss64.com/bash/kill.html)
     Stop a process from running  

  killall  Kill processes by name  

l  

  [less](http://ss64.com/bash/less.html)
     Display output one screen at a time  

  [let](http://ss64.com/bash/let.html)
      Perform arithmetic on shell variables  

  [ln](http://ss64.com/bash/ln.html)
       Make links between files  

  [local](http://ss64.com/bash/local.html)
    Create variables  

  [locate](http://ss64.com/bash/locate.html)
   Find files  

  [logname](http://ss64.com/bash/logname.html)
  Print current login name  

  [logout](http://ss64.com/bash/logout.html)
   Exit a login shell  

  [look](http://ss64.com/bash/look.html)
     Display lines beginning with a given string  

  [lpc](http://ss64.com/bash/lpc.html)
      Line printer control program  

  [lpr](http://ss64.com/bash/lpr.html)
      Off line print  

  lprint   Print a file  

  lprintd  Abort a print job  

  lprintq  List the print queue  

  [lprm](http://ss64.com/bash/lprm.html)
     Remove jobs from the print queue  

  [ls](http://ss64.com/bash/ls.html)
       List information about file(s)  

  [lsof](http://ss64.com/bash/lsof.html)
     List open files  

m  

  make     Recompile a group of programs  

  [man](http://ss64.com/bash/man.html)
      Help manual  

  [mkdir](http://ss64.com/bash/mkdir.html)
    Create new folder(s)  

  [mkfifo](http://ss64.com/bash/mkfifo.html)
   Make FIFOs (named pipes)  

  mkisofs  Create an hybrid ISO9660/JOLIET/HFS filesystem  

  [mknod](http://ss64.com/bash/mknod.html)
    Make block or character special files  

  [more](http://ss64.com/bash/more.html)
     Display output one screen at a time  

  [mount](http://ss64.com/bash/mount.html)
    Mount a file system  

  [mtools](http://ss64.com/bash/mtools.html)
   Manipulate MS-DOS files  

  [mv](http://ss64.com/bash/mv.html)
       Move or rename files or directories  

  [mmv](http://ss64.com/bash/mmv.html)
      Mass Move and rename (files)  

n  

  netstat  Networking information  

  [nice](http://ss64.com/bash/nice.html)
     Set the priority of a command or job  

  [nl](http://ss64.com/bash/nl.html)
       Number lines and write files  

  [nohup](http://ss64.com/bash/nohup.html)
    Run a command immune to hangups  

  [nslookup](http://ss64.com/bash/nslookup.html)
 Query Internet name servers interactively  

o  

  [open](http://ss64.com/bash/open.html)
     Open a file in its default application  

  [op](http://ss64.com/bash/op.html)
       Operator access   

p  

  [passwd](http://ss64.com/bash/passwd.html)
   Modify a user password  

  [paste](http://ss64.com/bash/paste.html)
    Merge lines of files  

  pathchk  Check file name portability  

  [ping](http://ss64.com/bash/ping.html)
     Test a network connection  

  [pkill](http://ss64.com/bash/pkill.html)
    Stop processes from running  

  [popd](http://ss64.com/bash/popd.html)
     Restore the previous value of the current directory  

  [pr](http://ss64.com/bash/pr.html)
       Prepare files for printing  

  printcap Printer capability database  

  printenv Print environment variables  

  [printf](http://ss64.com/bash/printf.html)
   Format and print data  

  [ps](http://ss64.com/bash/ps.html)
       Process status  

  [pushd](http://ss64.com/bash/pushd.html)
    Save and then change the current directory  

  [pwd](http://ss64.com/bash/pwd.html)
      Print Working Directory  

q  

  [quota](http://ss64.com/bash/quota.html)
    Display disk usage and limits  

  [quotacheck](http://ss64.com/bash/quotacheck.html)
 Scan a file system for disk usage  

  [quotactl](http://ss64.com/bash/quotactl.html)
 Set disk quotas  

r  

  [ram](http://ss64.com/bash/ram.html)
      ram disk device  

  [rcp](http://ss64.com/bash/rcp.html)
      Copy files between two machines  

  [read](http://ss64.com/bash/read.html)
     read a line from standard input  

  [readonly](http://ss64.com/bash/readonly.html)
 Mark variables/functions as readonly  

  reboot   Reboot the system  

  renice   Alter priority of running processes   

  remsync  Synchronize remote files via email  

  [return](http://ss64.com/bash/return.html)
   Exit a shell function  

  [rev](http://ss64.com/bash/rev.html)
      Reverse lines of a file  

  [rm](http://ss64.com/bash/rm.html)
       Remove files  

  [rmdir](http://ss64.com/bash/rmdir.html)
    Remove folder(s)  

  [rsync](http://ss64.com/bash/rsync.html)
    Remote file copy (Synchronize file trees)  

s  

  [screen](http://ss64.com/bash/screen.html)
   Multiplex terminal, run remote shells via ssh  

  [scp](http://ss64.com/bash/scp.html)
      Secure copy (remote file copy)  

  [sdiff](http://ss64.com/bash/sdiff.html)
    Merge two files interactively  

  [sed](http://ss64.com/bash/sed.html)
      Stream Editor  

  [select](http://ss64.com/bash/select.html)
   Accept keyboard input  

  [seq](http://ss64.com/bash/seq.html)
      Print numeric sequences  

  [set](http://ss64.com/bash/set.html)
      Manipulate shell variables and functions  

  sftp     Secure File Transfer Program  

  [shift](http://ss64.com/bash/shift.html)
    Shift positional parameters  

  [shopt](http://ss64.com/bash/shopt.html)
    Shell Options  

  [shutdown](http://ss64.com/bash/shutdown.html)
 Shutdown or restart linux  

  [sleep](http://ss64.com/bash/sleep.html)
    Delay for a specified time  

  [slocate](http://ss64.com/bash/slocate.html)
  Find files  

  [sort](http://ss64.com/bash/sort.html)
     Sort text files  

  [source](http://ss64.com/bash/source.html)
   Run commands from a file `.'  

  [split](http://ss64.com/bash/split.html)
    Split a file into fixed-size pieces  

  [ssh](http://en.wikipedia.org/wiki/Secure_Shell)
      Secure Shell client (remote login program)  

  strace   Trace system calls and signals  

  [su](http://ss64.com/bash/su.html)
       Substitute user identity  

  [sudo](http://ss64.com/bash/sudo.html)
     Execute a command as another user  

  [sum](http://ss64.com/bash/sum.html)
      Print a checksum for a file  

  [symlink](http://ss64.com/bash/symlink.html)
  Make a new name for a file  

  [sync](http://ss64.com/bash/sync.html)
     Synchronize data on disk with memory  

t  

  [tail](http://ss64.com/bash/tail.html)
     Output the last part of files  

  [tar](http://ss64.com/bash/tar.html)
      Tape ARchiver  

  [tee](http://ss64.com/bash/tee.html)
      Redirect output to multiple files  

  [test](http://ss64.com/bash/test.html)
     Evaluate a conditional expression  

  [time](http://ss64.com/bash/time.html)
     Measure Program running time  

  [times](http://ss64.com/bash/times.html)
    User and system times  

  [touch](http://ss64.com/bash/touch.html)
    Change file timestamps  

  [top](http://ss64.com/bash/top.html)
      List processes running on the system  

  [traceroute](http://ss64.com/bash/traceroute.html)
 Trace Route to Host  

  trap     Run a command when a signal is set(bourne)  

  [tr](http://ss64.com/bash/tr.html)
       Translate, squeeze, and/or delete characters  

  [true](http://ss64.com/bash/true.html)
     Do nothing, successfully  

  [tsort](http://ss64.com/bash/tsort.html)
    Topological sort  

  [tty](http://ss64.com/bash/tty.html)
      Print filename of terminal on stdin  

  [type](http://ss64.com/bash/type.html)
     Describe a command  

u  

  [ulimit](http://ss64.com/bash/ulimit.html)
   Limit user resources  

  [umask](http://ss64.com/bash/umask.html)
    Users file creation mask  

  umount   Unmount a device  

  [unalias](http://ss64.com/bash/alias.html)
  Remove an alias  

  [uname](http://ss64.com/bash/uname.html)
    Print system information  

  [unexpand](http://ss64.com/bash/unexpand.html)
 Convert spaces to tabs  

  [uniq](http://ss64.com/bash/uniq.html)
     Uniquify files  

  [units](http://ss64.com/bash/units.html)
    Convert units from one scale to another  

  [unset](http://ss64.com/bash/unset.html)
    Remove variable or function names  

  [unshar](http://ss64.com/bash/unshar.html)
   Unpack shell archive scripts  

  [until](http://ss64.com/bash/until.html)
    Execute commands (until error)  

  [useradd](http://ss64.com/bash/useradd.html)
  Create new user account  

  [usermod](http://ss64.com/bash/usermod.html)
  Modify user account  

  [users](http://ss64.com/bash/users.html)
    List users currently logged in  

  [uuencode](http://ss64.com/bash/uuencode.html)
 Encode a binary file   

  [uudecode](http://ss64.com/bash/uuencode.html)
 Decode a file created by uuencode  

v  

  v        Verbosely list directory contents (`ls -l -b')  

  vdir     Verbosely list directory contents (`ls -l -b')  

  [vi](http://ss64.com/bash/vi.html)
       Text Editor  

  [vmstat](http://ss64.com/bash/vmstat.html)
   Report virtual memory statistics  

w  

  [watch](http://ss64.com/bash/watch.html)
    Execute/display a program periodically  

  [wc](http://ss64.com/bash/wc.html)
       Print byte, word, and line counts  

  [whereis](http://ss64.com/bash/whereis.html)
  Report all known instances of a command      

  [which](http://ss64.com/bash/which.html)
    Locate a program file in the user's path.   

  [while](http://ss64.com/bash/while.html)
    Execute commands  

  [who](http://ss64.com/bash/who.html)
      Print all usernames currently logged in  

  [whoami](http://ss64.com/bash/whoami.html)
   Print the current user id and name (`id -un')  

  Wget     Retrieve web pages or files via HTTP, HTTPS or FTP  

  [write](http://ss64.com/bash/write.html)
    Send a message to another user   

x  

  [xargs](http://ss64.com/bash/xargs.html)
    Execute utility, passing constructed argument list(s)  

  [yes](http://ss64.com/bash/yes.html)
      Print a string until interrupted  

  [.](http://ss64.com/bash/source.html)
        Run a command script in the current shell  

  [###](http://ss64.com/bash/rem.html)
      Comment / Remark  
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/10/28/4738699/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/10/28/4738699/" class="post-title-link" itemprop="url">Linux 脚本 Sed</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-10-28 15:46:00" itemprop="dateCreated datePublished" datetime="2009-10-28T15:46:00+08:00">2009-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-08 16:59:15" itemprop="dateModified" datetime="2023-10-08T16:59:15+08:00">2023-10-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>18 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载自：</p>
<p><a target="_blank" rel="noopener" href="http://www-900.ibm.com/developerWorks/cn/linux/shell/sed/sed-1/index.shtml"> http://www.ibm.com/developerworks/cn/linux/shell/sed/sed-1/index.html<br />
</a><br />
<a target="_blank" rel="noopener" href="http://www-900.ibm.com/developerWorks/cn/linux/shell/sed/sed-1/index.shtml"> http://www.ibm.com/developerworks/cn/linux/shell/sed/sed-2/index.html<br />
</a><br />
<a target="_blank" rel="noopener" href="http://www-900.ibm.com/developerWorks/cn/linux/shell/sed/sed-1/index.shtml"> http://www.ibm.com/developerworks/cn/linux/shell/sed/sed-3/index.html<br />
</a></p>
<p>在 UNIX 世界中有很多文本编辑器可供我们选择。思考一下 – vi、emacs 和 jed<br />
以及很多其它工具都会浮现在脑海中。我们都有自己已逐渐了解并且喜爱的编辑器（以及我们喜爱的组合键）。有了可信赖的编辑器，我们可以轻松处理任何数量与 UNIX<br />
有关的管理或编程任务。</p>
<p>虽然交互式编辑器很棒，但却有其限制。尽管其交互式特性可以成为强项，但也有其不足之处。考虑一下需要对一组文件执行类似更改的情形。您可能会本能地运行自己所喜爱的<br />
编辑器，然后手工执行一组烦琐、重复和耗时的编辑任务。然而，有一种更好的方法。</p>
<p>进入 sed<br />
如果可以使编辑文件的过程自动化，以便用“批处理”方式编辑文件，甚至编写可以对现有文件进行复杂更改的脚本，那将太好了。幸运的是，对于这种情况，有一种更好的方法<br />
– 这种更好的方法称为 “sed”。</p>
<p>sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed<br />
有许多很好的特性。首先，它相当小巧，通常要比您所喜爱的脚本语言小很多倍。其次，因为 sed<br />
是一种流编辑器，所以，它可以对从如管道这样的标准输入接收的数据进行编辑。因此，无需将要编辑的数据存储在磁盘上的文件中。因为可以轻易将数据管道输出 到<br />
sed，所以，将 sed 用作强大的 shell 脚本中长而复杂的管道很容易。试一下用您所喜爱的编辑器去那样做。</p>
<p>GNU sed<br />
对 Linux 用户来说幸运的是，最好的 sed 版本之一恰好是 GNU sed，其当前版本是 3.02。每一个 Linux<br />
发行版都有（或至少应该有）GNU sed。GNU sed 之所以流行不仅因为可以自由分发其源代码，还因为它恰巧有许多对 POSIX sed<br />
标准便利、省时的扩展。另外，GNU 没有 sed 早期专门版本的很多限制，如行长度限制 – GNU 可以轻松处理任意长度的行。</p>
<p>最新的 GNU sed<br />
在 研究这篇文章之时我注意到：几个在线 sed 爱好者提到 GNU sed<br />
3.02a。奇怪的是，<span class="exturl" data-url="aHR0cDovL3huLS1mdHAtbHA2ZS5nbnUub3Jn">在ftp.gnu.org<i class="fa fa-external-link-alt"></i></span>（有关这些链接，请参阅参考资料）上找不到 sed<br />
3.02a，所以，我只得在别处寻找。<span class="exturl" data-url="aHR0cDovL3huLS1hbHBoYS04dzJpdTU2ZC5nbnUub3Jn">我在alpha.gnu.org<i class="fa fa-external-link-alt"></i></span> 的 /pub/sed<br />
中找到了它。于是我高兴地将其下载、编译然后安装，而几分钟后我发现最新的 sed 版本却是 3.02.80 – <span class="exturl" data-url="aHR0cDovL3huLS1hbHBoYS10djhocDZxLmdudS5vcmc=">可在alpha.gnu.org<i class="fa fa-external-link-alt"></i></span> 上<br />
3.02a 源代码旁边找到其源代码。安装完 GNU sed 3.02.80 之后，我就完全准备好了。</p>
<p><span class="exturl" data-url="aHR0cDovL2FscGhhLmdudS5vcmc=">alpha.gnu.org<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cDovL2FscGhhLmdudS5vcmc=">alpha.gnu.org<i class="fa fa-external-link-alt"></i></span>（请 参阅参考资料）是新的和实验性 GNU 源代码的所在地。然而，您还会在那里发现许多优秀、稳定的源代码。出于某种原因，不是许多<br />
GNU 开发人员忘记将稳定的源代码移至 <span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3Jn">ftp.gnu.org<i class="fa fa-external-link-alt"></i></span>，就是它们的 “beta” 期间格外长（2 年！）。例如，sed 3.02a 已有两年，甚至<br />
3.02.80 也有一年，但它们仍不能（在 2000 年 8 月写本文章时）在 <span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3Jn">ftp.gnu.org<i class="fa fa-external-link-alt"></i></span> 上获得。</p>
<p>正确的 sed<br />
在 本系列中，将使用 GNU sed 3.02.80。在即将出现的本系列后续文章中，某些（但非常少）最高级的示例将不能在 GNU sed 3.02 或<br />
3.02a 中使用。如果您使用的不是 GNU sed，那么结果可能会不同。现在为什么不花些时间安装 GNU sed 3.02.80<br />
呢？那样，不仅可以为本系列的余下部分作好准备，而且还可以使用可能是目前最好的 sed。</p>
<p>sed 示例<br />
sed 通过对输入数据执行任意数量用户指定的编辑操作（“命令”）来工作。sed 是基于行的，因此按顺序对每一行执行命令。然后，sed 将其结果写入标准输出<br />
(stdout)，它不修改任何输入文件。</p>
<p>让我们看一些示例。头几个会有些奇怪，因为我要用它们演示 sed 如何工作，而不是执行任何有用的任务。然而，如果您是 sed<br />
新手，那么理解它们是十分重要的。下面是第一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;d&#x27;</span> /etc/services  </span><br></pre></td></tr></table></figure>
<p>如 果输入该命令，将得不到任何输出。那么，发生了什么？在该例中，用一个编辑命令 ‘d’ 调用 sed。sed 打开 /etc/services<br />
文件，将一行读入其模式缓冲区，执行编辑命令（“删除行”），然后打印模式缓冲区（缓冲区已为空）。然后，它对后面的每一行重复这些步骤。这不会产生输 出，因为<br />
“d” 命令除去了模式缓冲区中的每一行！</p>
<p>在该例中，还有几件事要注意。首先，根本没有修改 /etc/services。这还是因为 sed 只读取在命令行指定的文件，将其用作输入 –<br />
它不试图修改该文件。第二件要注意的事是 sed 是面向行的。‘d’ 命令不是简单地告诉 sed 一下子删除所有输入数据。相反，sed 逐行将<br />
/etc/services 的每一行读入其称为模式缓冲区的内部缓冲区。一旦将一行读入模式缓冲区，它就执行 ‘d’<br />
命令，然后打印模式缓冲区的内容（在本例中没有内容）。我将在后面为您演示如何使用地址范围来控制将命令应用到哪些行 –<br />
但是，如果不使用地址，命令将应用到所有行。</p>
<p>第三件要注意的事是括起 ‘d’ 命令的单引号的用法。养成使用单引号来括起 sed 命令的习惯是个好注意，这样可以禁用 shell 扩展。</p>
<p>另一个 sed 示例<br />
下面是使用 sed 从输出流除去 /etc/services 文件第一行的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;1d&#x27;</span> /etc/services | more  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如 您所见，除了前面有 <span class="string">&#x27;1&#x27;</span> 之外，该命令与第一个 <span class="string">&#x27;d&#x27;</span> 命令十分类似。如果您猜到 <span class="string">&#x27;1&#x27;</span> 指的是第一行，那您就猜对了。与第一个示例中只使用 <span class="string">&#x27;d&#x27;</span></span><br><span class="line">不同的是，这一次使用的 <span class="string">&#x27;d&#x27;</span> 前面有一个可选的数字地址。通过使用地址，可以告诉 sed 只对某一或某些特定行进行编辑。  </span><br><span class="line">  </span><br><span class="line">地址范围  </span><br><span class="line">现在，让我们看一下如何指定地址范围。在本例中，sed 将删除输出的第 1 到 10 行：  </span><br><span class="line">```bash</span><br><span class="line">$ sed -e <span class="string">&#x27;1,10d&#x27;</span> /etc/services | more  </span><br></pre></td></tr></table></figure>
<p>当用逗号将两个地址分开时，sed 将把后面的命令应用到从第一个地址开始、到第二个地址结束的范围。在本例中，将 ‘d’ 命令应用到第 1 到 10<br />
行（包括这两行）。所有其它行都被忽略。</p>
<p>带规则表达式的地址<br />
现 在演示一个更有用的示例。假设要查看 /etc/services 文件的内容，但是对查看其中包括的注释部分不感兴趣。如您所知，可以通过以 ‘#’<br />
字符开头的行在 /etc/services 文件中放置注释。为了避免注释，我们希望 sed 删除以 ‘#’ 开始的行。以下是具体做法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/^#/d&#x27;</span> /etc/services | more  </span><br></pre></td></tr></table></figure>
<p>试一下该例，看看发生了什么。您将注意到，sed 成功完成了预期任务。现在，让我们分析发生的情况。</p>
<p>要 理解 ‘/^#/d’ 命令，首先需要对其剖析。首先，让我们除去 ‘d’ – 这是我们前面所使用的同一个删除行命令。新增加的是 ‘/^#/’<br />
部分，它是一种新的规则表达式地址。规则表达式地址总是由斜杠括起。它们指定一种 模式，紧跟在规则表达式地址之后的命令将仅适用于正好与该特定模式匹配的行。</p>
<p>因此，‘/^#/’ 是一个规则表达式。但是，它做些什么呢？很明显，现在该复习规则表达式了。</p>
<p>规则表达式复习<br />
可以使用规则表达式来表示可能会在文本中发现的模式。您在 shell 命令行中用过 ‘*’<br />
字符吗？这种用法与规则表达式类似，但并不相同。下面是可以在规则表达式中使用的特殊字符：</p>
<p>字符 描述<br />
与行首匹配<br />
与行末尾匹配<br />
与任一个字符匹配<br />
将与前一个字符的零或多个出现匹配<br />
[ ] 与 [ ] 之内的所有字符匹配</p>
<p>感受规则表达式的最好方法可能是看几个示例。所有这些示例都将被 sed 作为合法地址接受，这些地址出现在命令的左边。下面是几个示例：</p>
<p>规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">表达式 描述  </span><br><span class="line">/./ 将与包含至少一个字符的任何行匹配  </span><br><span class="line">/../ 将与包含至少两个字符的任何行匹配  </span><br><span class="line">/^#/ 将与以 &#x27;#&#x27; 开始的任何行匹配  </span><br><span class="line">/^$/ 将与所有空行匹配  </span><br><span class="line">/&#125;^/ 将与以 &#x27;&#125;&#x27;（无空格）结束的任何行匹配  </span><br><span class="line">/&#125; *^/ 将与以 &#x27;&#125;&#x27; 后面跟有零或多个空格结束的任何行匹配  </span><br><span class="line">/[abc]/ 将与包含小写 &#x27;a&#x27;、&#x27;b&#x27; 或 &#x27;c&#x27; 的任何行匹配  </span><br><span class="line">/^[abc]/ 将与以 &#x27;a&#x27;、&#x27;b&#x27; 或 &#x27;c&#x27;开始的任何行匹配  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这些示例中，鼓励您尝试几个。花一些时间熟悉规则表达式，然后尝试几个自己创建的规则表达式。可以如下使用 regexp：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/regexp/d&#x27;</span> /path/to/my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>这将导致 sed 删除任何匹配的行。然而，通过告诉 sed打印 regexp<br />
匹配并删除不匹配的内容，而不是与之相反的方法，会更有利于熟悉规则表达式。可以用以下命令这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/regexp/p&#x27;</span> /path/to/my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>请注意新的 ‘-n’ 选项，该选项告诉 sed 除非明确要求打印模式空间，否则不这样做。您还会注意到，我们用 ‘p’ 命令替换了 ‘d’<br />
命令，如您所猜想的那样，这明确要求 sed 打印模式空间。就这样，将只打印匹配部分。</p>
<p>有关地址的更多内容<br />
目 前为止，我们已经看到了行地址、行范围地址和 regexp 地址。但是，还有更多的可能。我们可以指定两个用逗号分开的规则表达式，sed<br />
将与所有从匹配第一个规则表达式的第一行开始，到匹配第二个规则表达式的行结束（包括该行）的所有行匹配。例如，以下命令将打印从包含 “BEGIN”<br />
的行开始，并且以包含 “END” 的行结束的文本块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/BEGIN/,/END/p&#x27;</span> /my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>如果没发现 “BEGIN”，那么将不打印数据。如果发现了 “BEGIN”，但是在这之后的所有行中都没发现<br />
“END”，那么将打印所有后续行。发生这种情况是因为 sed 面向流的特性 – 它不知道是否会出现 “END”。</p>
<p>C 源代码示例<br />
如果只要打印 C 源文件中的 main() 函数，可输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/main[[:space:]]*(/,/^&#125;/p&#x27;</span> sourcefile.c | more  </span><br></pre></td></tr></table></figure>
<p>该 命令有两个规则表达式 ‘/main[[:space:]]*(/’ 和 ‘/^}/’，以及一个命令<br />
‘p’。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 “main” 匹配。这应该与一般 ANSI C main()<br />
声明的开始匹配。</p>
<p>在这个特别的规则表达式中，出现了 ‘[[:space:]]’ 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB<br />
或空格匹配。如果愿意的话，可以不输入 ‘[[:space:]]’，而输入 ‘[’，然后是空格字母，然后是 -V，然后再输入制表键字母和 ‘]’ –<br />
Control-V 告诉 bash 要插入“真正”的制表键，而不是执行命令扩展。使用 ‘[[:space:]]’ 命令类（特别是在脚本中）会更清楚。</p>
<p>好，现在看一下第二个 regexp。‘/^}’ 将与任何出现在新行行首的 ‘}’ 字符匹配。如果代码的格式很好，那么这将与 main()<br />
函数的结束花括号匹配。如果格式不好，则不会正确匹配 – 这是执行模式匹配任务的一件棘手之事。</p>
<p>因为是处于 ‘-n’ 安静方式，所以 ‘p’ 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令 – 它应该输出整个<br />
main() { } 块，包括开始的 “main()” 和结束的 ‘}’。在 UNIX 世界中有很多文本编辑器可供我们选择。思考一下 – vi、emacs<br />
和 jed 以及很多其它工具都会浮现在脑海中。我们都有自己已逐渐了解并且喜爱的编辑器（以及我们喜爱的组合键）。有了可信赖的编辑器，我们可以轻松处理任何数量与<br />
UNIX 有关的管理或编程任务。</p>
<p>虽然交互式编辑器很棒，但却有其限制。尽管其交互式特性可以成为强项，但也有其不足之处。考虑一下需要对一组文件执行类似更改的情形。您可能会本能地运行自己所喜爱的<br />
编辑器，然后手工执行一组烦琐、重复和耗时的编辑任务。然而，有一种更好的方法。</p>
<p>进入 sed<br />
如果可以使编辑文件的过程自动化，以便用“批处理”方式编辑文件，甚至编写可以对现有文件进行复杂更改的脚本，那将太好了。幸运的是，对于这种情况，有一种更好的方法<br />
– 这种更好的方法称为 “sed”。</p>
<p>sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed<br />
有许多很好的特性。首先，它相当小巧，通常要比您所喜爱的脚本语言小很多倍。其次，因为 sed<br />
是一种流编辑器，所以，它可以对从如管道这样的标准输入接收的数据进行编辑。因此，无需将要编辑的数据存储在磁盘上的文件中。因为可以轻易将数据管道输出 到<br />
sed，所以，将 sed 用作强大的 shell 脚本中长而复杂的管道很容易。试一下用您所喜爱的编辑器去那样做。</p>
<p>GNU sed<br />
对 Linux 用户来说幸运的是，最好的 sed 版本之一恰好是 GNU sed，其当前版本是 3.02。每一个 Linux<br />
发行版都有（或至少应该有）GNU sed。GNU sed 之所以流行不仅因为可以自由分发其源代码，还因为它恰巧有许多对 POSIX sed<br />
标准便利、省时的扩展。另外，GNU 没有 sed 早期专门版本的很多限制，如行长度限制 – GNU 可以轻松处理任意长度的行。</p>
<p>最新的 GNU sed<br />
在 研究这篇文章之时我注意到：几个在线 sed 爱好者提到 GNU sed<br />
3.02a。奇怪的是，<span class="exturl" data-url="aHR0cDovL3huLS1mdHAtbHA2ZS5nbnUub3Jn">在ftp.gnu.org<i class="fa fa-external-link-alt"></i></span>（有关这些链接，请参阅参考资料）上找不到 sed<br />
3.02a，所以，我只得在别处寻找。<span class="exturl" data-url="aHR0cDovL3huLS1hbHBoYS04dzJpdTU2ZC5nbnUub3Jn">我在alpha.gnu.org<i class="fa fa-external-link-alt"></i></span> 的 /pub/sed<br />
中找到了它。于是我高兴地将其下载、编译然后安装，而几分钟后我发现最新的 sed 版本却是 3.02.80 – <span class="exturl" data-url="aHR0cDovL3huLS1hbHBoYS10djhocDZxLmdudS5vcmc=">可在alpha.gnu.org<i class="fa fa-external-link-alt"></i></span> 上<br />
3.02a 源代码旁边找到其源代码。安装完 GNU sed 3.02.80 之后，我就完全准备好了。</p>
<p><span class="exturl" data-url="aHR0cDovL2FscGhhLmdudS5vcmc=">alpha.gnu.org<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cDovL2FscGhhLmdudS5vcmc=">alpha.gnu.org<i class="fa fa-external-link-alt"></i></span>（请 参阅参考资料）是新的和实验性 GNU 源代码的所在地。然而，您还会在那里发现许多优秀、稳定的源代码。出于某种原因，不是许多<br />
GNU 开发人员忘记将稳定的源代码移至 <span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3Jn">ftp.gnu.org<i class="fa fa-external-link-alt"></i></span>，就是它们的 “beta” 期间格外长（2 年！）。例如，sed 3.02a 已有两年，甚至<br />
3.02.80 也有一年，但它们仍不能（在 2000 年 8 月写本文章时）在 <span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3Jn">ftp.gnu.org<i class="fa fa-external-link-alt"></i></span> 上获得。</p>
<p>正确的 sed<br />
在 本系列中，将使用 GNU sed 3.02.80。在即将出现的本系列后续文章中，某些（但非常少）最高级的示例将不能在 GNU sed 3.02 或<br />
3.02a 中使用。如果您使用的不是 GNU sed，那么结果可能会不同。现在为什么不花些时间安装 GNU sed 3.02.80<br />
呢？那样，不仅可以为本系列的余下部分作好准备，而且还可以使用可能是目前最好的 sed。</p>
<p>sed 示例<br />
sed 通过对输入数据执行任意数量用户指定的编辑操作（“命令”）来工作。sed 是基于行的，因此按顺序对每一行执行命令。然后，sed 将其结果写入标准输出<br />
(stdout)，它不修改任何输入文件。</p>
<p>让我们看一些示例。头几个会有些奇怪，因为我要用它们演示 sed 如何工作，而不是执行任何有用的任务。然而，如果您是 sed<br />
新手，那么理解它们是十分重要的。下面是第一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;d&#x27;</span> /etc/services  </span><br></pre></td></tr></table></figure>
<p>如 果输入该命令，将得不到任何输出。那么，发生了什么？在该例中，用一个编辑命令 ‘d’ 调用 sed。sed 打开 /etc/services<br />
文件，将一行读入其模式缓冲区，执行编辑命令（“删除行”），然后打印模式缓冲区（缓冲区已为空）。然后，它对后面的每一行重复这些步骤。这不会产生输 出，因为<br />
“d” 命令除去了模式缓冲区中的每一行！</p>
<p>在该例中，还有几件事要注意。首先，根本没有修改 /etc/services。这还是因为 sed 只读取在命令行指定的文件，将其用作输入 –<br />
它不试图修改该文件。第二件要注意的事是 sed 是面向行的。‘d’ 命令不是简单地告诉 sed 一下子删除所有输入数据。相反，sed 逐行将<br />
/etc/services 的每一行读入其称为模式缓冲区的内部缓冲区。一旦将一行读入模式缓冲区，它就执行 ‘d’<br />
命令，然后打印模式缓冲区的内容（在本例中没有内容）。我将在后面为您演示如何使用地址范围来控制将命令应用到哪些行 –<br />
但是，如果不使用地址，命令将应用到所有行。</p>
<p>第三件要注意的事是括起 ‘d’ 命令的单引号的用法。养成使用单引号来括起 sed 命令的习惯是个好注意，这样可以禁用 shell 扩展。</p>
<p>另一个 sed 示例<br />
下面是使用 sed 从输出流除去 /etc/services 文件第一行的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;1d&#x27;</span> /etc/services | more  </span><br></pre></td></tr></table></figure>
<p>如 您所见，除了前面有 ‘1’ 之外，该命令与第一个 ‘d’ 命令十分类似。如果您猜到 ‘1’ 指的是第一行，那您就猜对了。与第一个示例中只使用 ‘d’<br />
不同的是，这一次使用的 ‘d’ 前面有一个可选的数字地址。通过使用地址，可以告诉 sed 只对某一或某些特定行进行编辑。</p>
<p>地址范围<br />
现在，让我们看一下如何指定地址范围。在本例中，sed 将删除输出的第 1 到 10 行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;1,10d&#x27;</span> /etc/services | more  </span><br></pre></td></tr></table></figure>
<p>当用逗号将两个地址分开时，sed 将把后面的命令应用到从第一个地址开始、到第二个地址结束的范围。在本例中，将 ‘d’ 命令应用到第 1 到 10<br />
行（包括这两行）。所有其它行都被忽略。</p>
<p>带规则表达式的地址<br />
现 在演示一个更有用的示例。假设要查看 /etc/services 文件的内容，但是对查看其中包括的注释部分不感兴趣。如您所知，可以通过以 ‘#’<br />
字符开头的行在 /etc/services 文件中放置注释。为了避免注释，我们希望 sed 删除以 ‘#’ 开始的行。以下是具体做法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/^#/d&#x27;</span> /etc/services | more  </span><br></pre></td></tr></table></figure>
<p>试一下该例，看看发生了什么。您将注意到，sed 成功完成了预期任务。现在，让我们分析发生的情况。</p>
<p>要 理解 ‘/^#/d’ 命令，首先需要对其剖析。首先，让我们除去 ‘d’ – 这是我们前面所使用的同一个删除行命令。新增加的是 ‘/^#/’<br />
部分，它是一种新的规则表达式地址。规则表达式地址总是由斜杠括起。它们指定一种 模式，紧跟在规则表达式地址之后的命令将仅适用于正好与该特定模式匹配的行。</p>
<p>因此，‘/^#/’ 是一个规则表达式。但是，它做些什么呢？很明显，现在该复习规则表达式了。</p>
<p>规则表达式复习<br />
可以使用规则表达式来表示可能会在文本中发现的模式。您在 shell 命令行中用过 ‘*’<br />
字符吗？这种用法与规则表达式类似，但并不相同。下面是可以在规则表达式中使用的特殊字符：</p>
<p>字符 描述<br />
与行首匹配<br />
与行末尾匹配<br />
与任一个字符匹配<br />
将与前一个字符的零或多个出现匹配<br />
[ ] 与 [ ] 之内的所有字符匹配</p>
<p>感受规则表达式的最好方法可能是看几个示例。所有这些示例都将被 sed 作为合法地址接受，这些地址出现在命令的左边。下面是几个示例：</p>
<p>规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">表达式 描述  </span><br><span class="line">/./ 将与包含至少一个字符的任何行匹配  </span><br><span class="line">/../ 将与包含至少两个字符的任何行匹配  </span><br><span class="line">/^#/ 将与以 &#x27;#&#x27; 开始的任何行匹配  </span><br><span class="line">/^$/ 将与所有空行匹配  </span><br><span class="line">/&#125;^/ 将与以 &#x27;&#125;&#x27;（无空格）结束的任何行匹配  </span><br><span class="line">/&#125; *^/ 将与以 &#x27;&#125;&#x27; 后面跟有零或多个空格结束的任何行匹配  </span><br><span class="line">/[abc]/ 将与包含小写 &#x27;a&#x27;、&#x27;b&#x27; 或 &#x27;c&#x27; 的任何行匹配  </span><br><span class="line">/^[abc]/ 将与以 &#x27;a&#x27;、&#x27;b&#x27; 或 &#x27;c&#x27;开始的任何行匹配  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这些示例中，鼓励您尝试几个。花一些时间熟悉规则表达式，然后尝试几个自己创建的规则表达式。可以如下使用 regexp：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/regexp/d&#x27;</span> /path/to/my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>这将导致 sed 删除任何匹配的行。然而，通过告诉 sed打印 regexp<br />
匹配并删除不匹配的内容，而不是与之相反的方法，会更有利于熟悉规则表达式。可以用以下命令这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/regexp/p&#x27;</span> /path/to/my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>请注意新的 ‘-n’ 选项，该选项告诉 sed 除非明确要求打印模式空间，否则不这样做。您还会注意到，我们用 ‘p’ 命令替换了 ‘d’<br />
命令，如您所猜想的那样，这明确要求 sed 打印模式空间。就这样，将只打印匹配部分。</p>
<p>有关地址的更多内容<br />
目 前为止，我们已经看到了行地址、行范围地址和 regexp 地址。但是，还有更多的可能。我们可以指定两个用逗号分开的规则表达式，sed<br />
将与所有从匹配第一个规则表达式的第一行开始，到匹配第二个规则表达式的行结束（包括该行）的所有行匹配。例如，以下命令将打印从包含 “BEGIN”<br />
的行开始，并且以包含 “END” 的行结束的文本块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/BEGIN/,/END/p&#x27;</span> /my/test/file | more  </span><br></pre></td></tr></table></figure>
<p>如果没发现 “BEGIN”，那么将不打印数据。如果发现了 “BEGIN”，但是在这之后的所有行中都没发现<br />
“END”，那么将打印所有后续行。发生这种情况是因为 sed 面向流的特性 – 它不知道是否会出现 “END”。</p>
<p>C 源代码示例<br />
如果只要打印 C 源文件中的 main() 函数，可输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">&#x27;/main[[:space:]]*(/,/^&#125;/p&#x27;</span> sourcefile.c | more  </span><br></pre></td></tr></table></figure>
<p>该 命令有两个规则表达式 ‘/main[[:space:]]*(/’ 和 ‘/^}/’，以及一个命令<br />
‘p’。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 “main” 匹配。这应该与一般 ANSI C main()<br />
声明的开始匹配。</p>
<p>在这个特别的规则表达式中，出现了 ‘[[:space:]]’ 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB<br />
或空格匹配。如果愿意的话，可以不输入 ‘[[:space:]]’，而输入 ‘[’，然后是空格字母，然后是 -V，然后再输入制表键字母和 ‘]’ –<br />
Control-V 告诉 bash 要插入“真正”的制表键，而不是执行命令扩展。使用 ‘[[:space:]]’ 命令类（特别是在脚本中）会更清楚。</p>
<p>好，现在看一下第二个 regexp。‘/^}’ 将与任何出现在新行行首的 ‘}’ 字符匹配。如果代码的格式很好，那么这将与 main()<br />
函数的结束花括号匹配。如果格式不好，则不会正确匹配 – 这是执行模式匹配任务的一件棘手之事。</p>
<p>因为是处于 ‘-n’ 安静方式，所以 ‘p’ 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令 – 它应该输出整个<br />
main() { } 块，包括开始的 “main()” 和结束的 ‘}’。</p>
<p>替换！<br />
让我们看一下 sed 最有用的命令之一，替换命令。使用该命令，可以将特定字符串或匹配的规则表达式用另一个字符串替换。下面是该命令最基本用法的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;s/foo/bar/&#x27;</span> myfile.txt  </span><br></pre></td></tr></table></figure>
<p>上 面的命令将 myfile.txt 中每行第一次出现的 ‘foo’（如果有的话）用字符串 ‘bar’<br />
替换，然后将该文件内容输出到标准输出。请注意，我说的是每行第一次出现，尽管这通常不是您想要的。在进行字符串替换时，通常想执行全局替换。也就是说，<br />
要替换每行中的所有出现，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;s/foo/bar/g&#x27;</span> myfile.txt  </span><br></pre></td></tr></table></figure>
<p>在最后一个斜杠之后附加的 ‘g’ 选项告诉 sed 执行全局替换。</p>
<p>关于 ‘s///’ 替换命令，还有其它几件要了解的事。首先，它是一个命令，并且只是一个命令，在所有上例中都没有指定地址。这意味着，‘s///’<br />
还可以与地址一起使用来控制要将命令应用到哪些行，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;1,10s/enchantment/entrapment/g&#x27;</span> myfile2.txt  </span><br></pre></td></tr></table></figure>
<p>上例将导致用短语 ‘entrapment’ 替换所有出现的短语 ‘enchantment’，但是只在第一到第十行（包括这两行）上这样做。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/^$/,/^END/s/hills/mountains/g&#x27;</span> myfile3.txt  </span><br></pre></td></tr></table></figure>
<p>该例将用 ‘mountains’ 替换 ‘hills’，但是，只从空行开始，到以三个字符 ‘END’ 开始的行结束（包括这两行）的文本块上这样做。</p>
<p>关 于 ‘s///’ 命令的另一个妙处是 ‘/’ 分隔符有许多替换选项。如果正在执行字符串替换，并且规则表达式或替换字符串中有许多斜杠，则可以通过在 ‘s’<br />
之后指定一个不同的字符来更改分隔符。例如，下例将把所有出现的 /usr/local 替换成 /usr：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;s:/usr/local:/usr:g&#x27;</span> mylist.txt  </span><br></pre></td></tr></table></figure>
<p>在该例中，使用冒号作为分隔符。如果需要在规则表达式中指定分隔符字符，可以在它前面加入反斜杠。</p>
<p>规则表达式混乱<br />
目前为止，我们只执行了简单的字符串替换。虽然这很方便，但是我们还可以匹配规则表达式。例如，以下 sed 命令将匹配从 ‘&lt;’ 开始、到 ‘&gt;’<br />
结束、并且在其中包含任意数量字符的短语。下例将删除该短语（用空字符串替换）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;s/&lt;.*&gt;//g&#x27;</span> myfile.html  </span><br></pre></td></tr></table></figure>
<p>这 是要从文件除去 HTML 标记的第一个很好的 sed 脚本尝试，但是由于规则表达式的特有规则，它不会很好地工作。原因何在？当 sed<br />
试图在行中匹配规则表达式时，它要在行中查找最长的匹配。在我的前一篇 sed 文章中，这不成问题，因为我们使用的是 ‘d’ 和 ‘p’<br />
命令，这些命令总要删除或打印整行。但是，在使用 ‘s///’<br />
命令时，确实有很大不同，因为规则表达式匹配的整个部分将被目标字符串替换，或者，在本例中，被删除。这意味着，上例将把下行：</p>
<p><b>This</b> is what <b>I</b> meant.<br />
变成：</p>
<p>meant.<br />
我们要的不是这个，而是：</p>
<p>This is what I meant.<br />
幸 运的是，有一种简便方法来纠正该问题。我们不输入“‘&lt;’ 字符后面跟有一些字符并以 ‘&gt;’ 字符结束”的规则表达式，而只需输入一个“‘&lt;’<br />
字符后面跟有任意数量非 ‘&gt;’ 字符并以 ‘&gt;’ 字符结束”的规则表达式。这将与最短、而不是最长的可能性匹配。新命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;s/&lt;[^&gt;]*&gt;//g&#x27;</span> myfile.html  </span><br></pre></td></tr></table></figure>
<p>在上例中，‘[^&gt;]’ 指定“非 ‘&gt;’”字符，其后的 ‘*’ 完成该表达式以表示“零或多个非 ‘&gt;’ 字符”。对几个 html<br />
文件测试该命令，将它们管道输出到 “more”，然后仔细查看其结果。</p>
<p>更多字符匹配<br />
‘[ ]’ 规则表达式语法还有一些附加选项。要指定字符范围，只要字符不在第一个或最后一个位置，就可以使用 ‘-’，如下所示：</p>
<p>‘[a-x]*’<br />
这将匹配零或多个全部为 ‘a’、‘b’、‘c’…‘v’、‘w’、‘x’ 的字符。另外，可以使用 ‘[:space:]’<br />
字符类来匹配空格。以下是可用字符类的相当完整的列表：</p>
<p>字符类 描述<br />
[:alnum:] 字母数字 [a-z A-Z 0-9]<br />
[:alpha:] 字母 [a-z A-Z]<br />
[:blank:] 空格或制表键<br />
[:cntrl:] 任何控制字符<br />
[:digit:] 数字 [0-9]<br />
[:graph:] 任何可视字符（无空格）<br />
[:lower:] 小写 [a-z]<br />
[:print:] 非控制字符<br />
[:punct:] 标点字符<br />
[:space:] 空格<br />
[:upper:] 大写 [A-Z]<br />
[:xdigit:] 十六进制数字 [0-9 a-f A-F]</p>
<p>尽可能使用字符类是很有利的，因为它们可以更好地适应非英语 locale（包括某些必需的重音字符等等）.</p>
<p>高级替换功能<br />
我们已经看到如何执行简单甚至有些复杂的直接替换，但是 sed<br />
还可以做更多的事。实际上可以引用匹配规则表达式的部分或全部，并使用这些部分来构造替换字符串。作为示例，假设您正在回复一条消息。下例将在每一行前面加上短语<br />
&quot;ralph said: &quot;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e &#x27;s/.*/ralph said: &amp;/&#x27; origmsg.txt  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p>ralph said: Hiya Jim, ralph said: ralph said:<br />
I sure like this sed stuff! ralph said:<br />
该例的替换字符串中使用了 ‘&amp;’ 字符，该字符告诉 sed 插入整个匹配的规则表达式。因此，可以将与 ‘.*’<br />
匹配的任何内容（行中的零或多个字符的最大组或整行）插入到替换字符串中的任何位置，甚至多次插入。这非常好，但 sed 甚至更强大。</p>
<p>那些极好的带反斜杠的圆括号<br />
‘s///’ 命令甚至比 ‘&amp;’ 更好，它允许我们在规则表达式中定义区域，然后可以在替换字符串中引用这些特定区域。作为示例，假设有一个包含以下文本的文件：</p>
<p>foo bar oni eeny meeny miny larry curly moe jimmy the weasel<br />
现在假设要编写一个 sed 脚本，该脚本将把 “eeny meeny miny” 替换成 “Victor eeny-meeny Von miny”<br />
等等。要这样做，首先要编写一个由空格分隔并与三个字符串匹配的规则表达式。</p>
<p>‘.* .* .*’<br />
现在，将在其中每个感兴趣的区域两边插入带反斜杠的圆括号来定义区域：</p>
<p>‘/(.<em>/) /(.</em>/) /(.*/)’<br />
除了要定义三个可在替换字符串中引用的逻辑区域以外，该规则表达式的工作原理将与第一个规则表达式相同。下面是最终脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e &#x27;s//(.*/) /(.*/) /(.*/)/Victor /1-/2 Von /3/&#x27; myfile.txt  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如您所见，通过输入 ‘/x’（其中，x 是从 1 开始的区域号）来引用每个由圆括号定界的区域。输入如下：</p>
<p>Victor foo-bar Von oni Victor eeny-meeny Von miny Victor larry-curly Von moe<br />
Victor jimmy-the Von weasel<br />
随着对 sed 越来越熟悉，您可以花最小力气来进行相当强大的文本处理。您可能想如何使用熟悉的脚本语言来处理这种问题 –<br />
能用一行代码轻易实现这样的解决方案吗？</p>
<p>组合使用<br />
在 开始创建更复杂的 sed 脚本时，需要有输入多个命令的能力。有几种方法这样做。首先，可以在命令之间使用分号。例如，以下命令系列使用 ‘=’ 命令和<br />
‘p’ 命令，‘=’ 命令告诉 sed 打印行号，‘p’ 命令明确告诉 sed 打印该行（因为处于 ‘-n’ 模式）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e &#x27;=;p&#x27; myfile.txt  </span><br><span class="line"></span><br><span class="line">```无 论什么时候指定了两个或更多命令，都按顺序将每个命令应用到文件的每一行。在上例中，首先将 &#x27;=&#x27; 命令应用到第 1 行，然后应用 &#x27;p&#x27;</span><br><span class="line">命令。接着，sed 继续处理第 2 行，并重复该过程。虽然分号很方便，但是在某些场合下，它不能正常工作。另一种替换方法是使用两个 -e</span><br><span class="line">选项来指定两个不同的命令：  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>$ sed -n -e ‘=’ -e ‘p’ myfile.txt</p>
<figure class="highlight plaintext"><figcaption><span>'-e' 选项也不能帮我们的忙。对于复杂的多行脚本，最好的方法是将命令放入一个单独的文件中。然后，用 -f</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选项引用该脚本文件：  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>$ sed -n -f mycommands.sed myfile.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">一个地址的多个命令  </span><br><span class="line">有时，可能要指定应用到一个地址的多个命令。这在执行许多 &#x27;s///&#x27; 以变换源文件中的字和语法时特别方便。要对一个地址执行多个命令，可在文件中输入 sed</span><br><span class="line">命令，然后使用 &#x27;&#123; &#125;&#x27; 字符将这些命令分组，如下所示：  </span><br><span class="line">  </span><br><span class="line">1,20&#123; s/[Ll]inux/GNU//Linux/g s/samba/Samba/g s/posix/POSIX/g &#125;  </span><br><span class="line">上例将把三个替换命令应用到第 1 行到第 20 行（包括这两行）。还可以使用规则表达式地址或者二者的组合：  </span><br><span class="line">  </span><br><span class="line">1,/^END/&#123; s/[Ll]inux/GNU//Linux/g s/samba/Samba/g s/posix/POSIX/g p &#125;  </span><br><span class="line">该例将把 &#x27;&#123; &#125;&#x27; 之间的所有命令应用到从第 1 行开始，到以字母 &quot;END&quot; 开始的行结束（如果在源文件中没发现 &quot;END&quot;，则到文件结束）的所有行。  </span><br><span class="line">  </span><br><span class="line">附加、插入和更改行  </span><br><span class="line">既然在单独的文件中编写 sed 脚本，我们可以利用附加、插入和更改行命令。这些命令将在当前行之后插入一行，在当前行之前插入一行，或者替换模式空间中的当前行。</span><br><span class="line">它们也可以用来将多行插入到输出。插入行命令用法如下：  </span><br><span class="line">  </span><br><span class="line">i/ This line will be inserted before each line  </span><br><span class="line">如果不为该命令指定地址，那么它将应用到每一行，并产生如下的输出：  </span><br><span class="line">  </span><br><span class="line">This line will be inserted before each line line 1 here  </span><br><span class="line">This line will be inserted before each line line 2 here  </span><br><span class="line">This line will be inserted before each line line 3 here  </span><br><span class="line">This line will be inserted before each line line 4 here  </span><br><span class="line">如果要在当前行之前插入多行，可以通过在前一行之后附加一个反斜杠来添加附加行，如下所示：  </span><br><span class="line">  </span><br><span class="line">i/ insert this line/ and this one/ and this one/ and, uh, this one too.  </span><br><span class="line">附加命令的用法与之类似，但是它将把一行或多行插入到模式空间中的当前行之后。其用法如下：  </span><br><span class="line">  </span><br><span class="line">a/ insert this line after each line. Thanks!</span><br><span class="line">![smile.gif](http://www.loveunix.net/style_emoticons/default/smile.gif)  </span><br><span class="line">另一方面，“更改行”命令将实际替换模式空间中的当前行，其用法如下：  </span><br><span class="line">  </span><br><span class="line">c/ You&#x27;re history, original line! Muhahaha!  </span><br><span class="line">因为附加、插入和更改行命令需要在多行输入，所以将把它们输入到一个文本 sed 脚本中，然后通过使用 &#x27;-f&#x27; 选项告诉 sed</span><br><span class="line">执行它们。使用其它方法将命令传递给 sed 会出现问题。</span><br><span class="line"></span><br><span class="line">文本转换  </span><br><span class="line">第一个实际脚本将 UNIX 风格的文本转换成 DOS/Windows 格式。您可能知道，基于 DOS/Windows 的文本文件在每一行末尾有一个</span><br><span class="line">CR（回车）和 LF（换行），而 UNIX 文本只有一个换行。有时可能需要将某些 UNIX 文本移至 Windows 系统，该脚本将为您执行必需的格式转换。  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>$ sed -e ‘s/$//r/’ myunix.txt &gt; mydos.txt</p>
<figure class="highlight plaintext"><figcaption><span>规则表达式将与行的末尾匹配，而 '/r' 告诉 sed 在其之前插入一个回车。在换行之前插入回车，立即，每一行就以 CR/LF</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结束。请注意，仅当使用 GNU sed 3.02.80 或以后的版本时，才会用 CR 替换 &#x27;/r&#x27;。如果还没有安装 GNU sed</span><br><span class="line">3.02.80，请在我的第一篇 sed 文章中查看如何这样做的说明。  </span><br><span class="line">  </span><br><span class="line">我已记不清有多少次在下载一些示例脚本或 C 代码之后，却发现它是 DOS/Windows 格式。虽然很多程序不在乎 DOS/Windows 格式的</span><br><span class="line">CR/LF 文本文件，但是有几个程序却在乎 -- 最著名的是 bash，只要一遇到回车，它就会出问题。以下 sed 调用将把 DOS/Windows</span><br><span class="line">格式的文本转换成可信赖的 UNIX 格式：  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>$ sed -e ‘s/.$//’ mydos.txt &gt; myunix.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">除了输出中每行的最末字符，那么，您就指定了已经是 UNIX 格式的文本文件。也就没必要那样做了！  </span><br><span class="line">  </span><br><span class="line">反转行  </span><br><span class="line">下 面是另一个方便的小脚本。与大多数 Linux 发行版中包括的 &quot;tac&quot; 命令一样，该脚本将反转文件中行的次序。&quot;tac&quot;</span><br><span class="line">这个名称可能会给人以误导，因为 &quot;tac&quot; 不反转行中字符的位置（左和右），而是反转文件中行的位置（上和下）。用 &quot;tac&quot; 处理以下文件：  </span><br><span class="line">  </span><br><span class="line">foo bar oni  </span><br><span class="line">....将产生以下输出：  </span><br><span class="line">  </span><br><span class="line">oni bar foo  </span><br><span class="line">可以用以下 sed 脚本达到相同目的：  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>$ sed -e ‘1!G;h;$!d’ forward.txt &gt; backward.txt</p>
<pre class="highlight"><code class="如果登录到恰巧没有">  
反转解释  
首 先，该脚本包含三个由分号隔开的单独 sed 命令：'1!G'、'h' 和 '\$!d'。现在，需要好好理解用于第一个和第三个命令的地址。如果第一个命令是
'1G'，则 'G' 命令将只应用第一行。然而，还有一个 '!' 字符 -- 该 '!' 字符忽略该地址，即，'G'
命令将应用到除第一行之外的所有行。'\$!d' 命令与之类似。如果命令是 '\$d'，则将只把 'd' 命令应用到文件中的最后一行（'\$'
地址是指定最后一行的简单方式）。然而，有了 '!' 之后，'\$!d' 将把 'd'
命令应用到除最后一行之外的所有行。现在，我们所要理解的是这些命令本身做什么。  
  
当对上面的文本文件执行反转脚本时，首先执行的命令是 'h'。该命令告诉 sed
将模式空间（保存正在处理的当前行的缓冲区）的内容复制到保留空间（临时缓冲区）。然后，执行 'd' 命令，该命令从模式空间中删除
&quot;foo&quot;，以便在对这一行执行完所有命令之后不打印它。  
  
现在，第二行。在将 &quot;bar&quot; 读入模式空间之后，执行 'G' 命令，该命令将保留空间的内容 (&quot;foo/n&quot;) 附加到模式空间
(&quot;bar/n&quot;)，使模式空间的内容为 &quot;bar/n/foo/n&quot;。'h' 命令将该内容放回保留空间保护起来，然后，'d'
从模式空间删除该行，以便不打印它。  
  
对于最后的 &quot;oni&quot; 行，除了不删除模式空间的内容（由于 'd' 之前的 '\$!'）以及将模式空间的内容（三行）打印到标准输出之外，重复同样的步骤。  
  
现在，要用 sed 执行一些强大的数据转换。  
  
sed QIF 魔法  
过去几个星期，我一直想买一份 Quicken 来结算我的银行帐户。Quicken
是一个非常好的金融程序，当然会成功地完成这项工作。但是，经过考虑之后，我觉得自己可以轻易编写某个软件来结算我的支票簿。我想，毕竟，我是个软件开发人员！  
  
我 开发了一个很好的小型支票簿结算程序（使用 awk），它通过分析包含我的所有交易的文本文件的语法来计算余额。略微调整之后，我将其改进，以便可以象
Quicken 那样跟踪不同的贷款和借款类别。但是，我还要添加一个特性。最近，我将帐户转移到一家有联机 Web 帐户界面的银行。有一天，我注意到，这家银行的
Web 站点允许以 Quicken 的 .QIF 格式下载我的帐户信息。我马上觉得，如果可以将该信息转换成文本格式，那就太棒了。  
  
两种格式的故事  
在查看 QIF 格式之前，先看一下我的 checkbook.txt 格式：  
  
28 Aug 2000 food - - Y Supermarket 30.94 25 Aug 2000 watr - 103 Y Check 103
52.86  
在我的文件中，所有字段都由一个或多个制表符分开，每个交易占据一行。日期之后的下一个字段列 出支出类型（如果是收入项，则为
&quot;-&quot;）。第三个字段列出收入类型（如果是支出项，则为 &quot;-&quot;）。然后，是一个支票号字段（如果为空，则还是 &quot;-&quot;），一个交易完成字段（&quot;Y&quot; 或
&quot;N&quot;），一个注释和一个美元金额字段。现在，让我们看一下 QIF 格式。当用文本查看器查看下载的 QIF 文件时，它看起来如下：  
  
!Type:Bank D08/28/2000 T-8.15 N PCHECKCARD SUPERMARKET ^ D08/28/2000 T-8.25 N
PCHECKCARD PUNJAB RESTAURANT ^ D08/28/2000 T-17.17 N PCHECKCARD SUPERMARKET  
浏览过文件之后，不难猜出其格式 -- 忽略第一行，其余的格式如下：  
  
D&lt;数据&gt;  
T&lt;交易量&gt;  
N&lt;支票号&gt;  
P&lt;描述&gt;  
^ （这是字段分隔符）  
开始处理  
在处理象这样重要的 sed 项目时，不要气馁 -- sed 允许您将数据逐渐修改成最终形式。在进行当中，可以继续细化 sed
脚本，直到输出与预期的完全一样为止。无需在试第一次时就保证其完全正确。  
  
要开始，首先创建一个名为 &quot;qiftrans.sed&quot; 的文件，然后开始修改数据：  
  
1d /^^/d s/[[:cntrl:]]//g  
第一个 '1d' 命令删除第一行，第二个命令从输出除去那些讨厌的 '^' 字符。最后一行除去文件中可能存在的任何控制字符。既然在处理外来文件格式，我想消除在
中途遇到任何控制字符的风险。到目前为止，一切顺利。现在，要向该基本脚本中添加一些处理功能：  
  
1d /^^/d s/[[:cntrl:]]//g /^D/ &#123;  
s/^D/(.*/)//1/tOUTY/tINNY/t/  
s/^01/Jan/ s/^02/Feb/  
s/^03/Mar/ s/^04/Apr/  
s/^05/May/ s/^06/Jun/  
s/^07/Jul/ s/^08/Aug/  
s/^09/Sep/ s/^10/Oct/  
s/^11/Nov/ s/^12/Dec/  
s:^/(.*/)//(.*/)//(.*/):/2 /1 /3: &#125;  
首先，添加一个 '/^D/' 地址，以便 sed 只在遇到 QIF 数据字段的第一个字符 'D' 时才开始处理。当 sed
将这样一行读入其模式空间时，将按顺序执行花括号中的所有命令。  
  
花括号中的第一个命令将把如下行：  
  
D08/28/2000  
变换成：  
  
08/28/2000 OUTY INNY  
当然，现在的格式还不完美，但没关系。我们将在进行过程中逐渐细化模式空间的内容。后面 12
行的最后效果是将数据变换成三个字母的格式，最后一行从数据中除去三个斜杠。最后得到这一行：  
  
Aug 28 2000 OUTY INNY  
OUTY 和 INNY 字段是占位符，以后将被替换。现在还不能确定它们，因为如果美元金额为负，将把 OUTY 和 INNY 设置成 &quot;misc&quot; 和
&quot;-&quot;，但是，如果美元金额为正，将分别把它们更改成 &quot;-&quot; 和 &quot;inco&quot;。既然还没有读入美元金额，所以，需要暂时使用占位符。  
  
细化  
现在进一步细化：  
  
1d /^^/d s/[[:cntrl:]]//g /^D/ &#123;  
s/^D/(.*/)//1/tOUTY/tINNY/t/  
s/^01/Jan/ s/^02/Feb/  
s/^03/Mar/ s/^04/Apr/  
s/^05/May/ s/^06/Jun/  
s/^07/Jul/ s/^08/Aug/  
s/^09/Sep/ s/^10/Oct/  
s/^11/Nov/ s/^12/Dec/  
s:^/(.*/)//(.*/)//(.*/):/2 /1 /3:  
N N N  
s//nT/(.*/)/nN/(.*/)/nP/(.*/)/NUM/2NUM/t/tY/t/t/3/tAMT/1AMT/  
s/NUMNUM/-/ s/NUM/([0-9]*/)NUM//1/  
s//([0-9]/),//1/ &#125;  
后七行有些复杂，所以将详细讨论它们。首先，连续使用三个 'N' 命令。'N' 命令告诉 sed 将下一行读入输入中，然后将其附加到当前模式空间。这三个
'N' 命令导致将下三行附加到当前模式空间缓冲区，现在这一行看起来如下：  
  
28 Aug 2000 OUTY INNY /nT-8.15/nN/nPCHECKCARD SUPERMARKET  
sed 的模式空间变得很难看 -- 需要除去额外的新行，并执行某些附加的格式化。要这样做，将使用替代命令。要匹配的模式为：  
  
'/nT.*/nN.*/nP.*'  
这 将与后面依次跟有
'T'、零或多个字符、新行、'N'、任何数量的字符、新行、'P'、以及任何数量字符的新行匹配。呀！这个规则表达式将与刚刚附加到模式空间的三行的全
部内容匹配。但我们要重新格式化该区域，而不是整个替换它。美元金额、支票号（如果有的话）和描述需要出现在替换字符串中。要这样做，我们用带有反斜杠的
圆括号括起那些“感兴趣部分”，以便可以在替换字符串中引用它们（使用 '/1'、'/2/ 和 '/3' 来告诉 sed 将它们插入到何处）。以下是最后的命令：  
  
s//nT/(.*/)/nN/(.*/)/nP/(.*/)/NUM/2NUM/t/tY/t/t/3/tAMT/1AMT/  
该命令将我们的行变换成：  
  
28 Aug 2000 OUTY INNY NUMNUM Y CHECKCARD SUPERMARKET AMT-8.15AMT  
虽 然该行正变得好一些，但是，有几件事一看就有点...啊...有趣。首先是那个愚蠢的 &quot;NUMNUM&quot; 字符串 -- 其目的何在？如果查看 sed
脚本的后两行，就会发现其目的，后两行将把 &quot;NUMNUM&quot; 替换成 &quot;-&quot;，而把 &quot;NUM&quot;&lt;number&gt;&quot;NUM&quot; 替换成
&lt;number&gt;。如您所见，用愚蠢的标记括起支票号允许我们在该字段为空时方便地插入一个 &quot;-&quot;。  
  
结束尝试  
最后一行除去数字后的逗号。它把如 &quot;3,231.00&quot; 这样的美元金额转换成我使用的格式 &quot;3231.00&quot;。现在，让我们看一下最终脚本：  
  
最终的“QIF 到文本”脚本 1d /^^/d s/[[:cntrl:]]//g /^D/ &#123; s/^D/(.*/)//1/tOUTY/tINNY/t/  
s/^01/Jan/ s/^02/Feb/ s/^03/Mar/ s/^04/Apr/ s/^05/May/  
s/^06/Jun/ s/^07/Jul/ s/^08/Aug/ s/^09/Sep/ s/^10/Oct/  
s/^11/Nov/ s/^12/Dec/ s:^/(.*/)//(.*/)//(.*/):/2 /1 /3:  
N N N s//nT/(.*/)/nN/(.*/)/nP/(.*/)/NUM/2NUM/t/tY/t/t/3/tAMT/1AMT/  
s/NUMNUM/-/ s/NUM/([0-9]*/)NUM//1/ s//([0-9]/),//1/  
/AMT-[0-9]*.[0-9]*AMT/b fixnegs  
s/AMT/(.*/)AMT//1/ s/OUTY/-/ s/INNY/inco/  
b done :fixnegs s/AMT-/(.*/)AMT//1/ s/OUTY/misc/  
s/INNY/-/ :done &#125;  
附加的十一行使用替代和一些分支功能来美化输出。首先看一下这行：  
  
/AMT-[0-9]*.[0-9]*AMT/b fixnegs  
该行包含一个格式为 &quot;/regexp/b label&quot; 的分支命令。如果模式空间与规则表达式匹配，sed 将分支到 fixnegs
标号。您应该可以轻易找到该标号，它在代码中为 &quot;:fixnegs&quot;。如果规则表达式不匹配，则以常规方式继续处理下一个命令。  
  
既 然您理解该命令本身的工作原理，让我们看一下分支。如果看一下分支规则表达式，将看到它与后面依次跟有 '-'、任意数量的数字、一个 '.'、任意数量的数字和
'AMT' 的字符串 'AMT' 匹配。就象我确信您已猜到一样，该规则表达式专门处理负的美元金额。在这之前，用 'ATM'
括起美元金额，以便以后可以轻易找到它。因为规则表达式只与以 '-' 开始的美元金额匹配，所以，该分支只在恰巧处理借款时才发生。如果正处理贷款，应该将
OUTY 设置成 'misc'，将 INNY 设置成
'-'，并且应该除去贷款数量前面的负号。如果跟踪代码的流程，将看到实际情况正是这样。如果不执行分支，则用 '-' 替换 OUTY，用 'inco' 替换
INNY。完成了！现在输出行是完美的：  
  
28 Aug 2000 misc - - Y CHECKCARD SUPERMARKET -8.15  
别犯糊涂  
如 您所见，只要循序渐进地解决问题，使用 sed 转换数据就没有那么难。不要试图使用一个 sed
命令或一下子解决所有问题。相反，要朝着目标逐步进行，并不断改进 sed 脚本，直到其输出正如您希望那样为止。sed
有许多功能，希望您已非常熟悉其内部工作原理并继续努力以进一步掌握它！

</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/10/28/4737259/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/10/28/4737259/" class="post-title-link" itemprop="url">Linux脚本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-10-28 10:57:00" itemprop="dateCreated datePublished" datetime="2009-10-28T10:57:00+08:00">2009-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-07 12:37:46" itemprop="dateModified" datetime="2023-10-07T12:37:46+08:00">2023-10-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>15 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章还是有些错误的，再脚本中如果写大段的echo文字时，需要使用如下的方式：</p>
<p>cat &lt;&lt;-HELP</p>
<p>这里是你的内容，HELP只不过是标识。但是一定要注意cat命令后两个小于后“-”,如果不加，语法会有错误。我辛苦的找了很久…</p>
<p>HELP</p>
<p>另外清晰的地址在</p>
<p><span class="exturl" data-url="aHR0cDovL3dpa2kudWJ1bnR1Lm9yZy5jbi9TaGVsbCVFNyVCQyU5NiVFNyVBOCU4QiVFNSU5RiVCQSVFNyVBMSU4MA==">http://wiki.ubuntu.org.cn/Shell编程基础<i class="fa fa-external-link-alt"></i></span></p>
<p>不过它那里的文章中的cat也写错了。或者是bash版本不同的关系吧。</p>
<p>此文章参照:</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGRpeWYuY29tL3ZpZXdhcnRpY2xlLnBocD9pZD0yMDMzOA==">http://www.linuxdiyf.com/viewarticle.php?id=20338<i class="fa fa-external-link-alt"></i></span> 有严寒发表于 2006-9-29</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuY2hlc3Mub3JnL25vaXRhdHNrby9wcm9ncmFtbWluZy8=">http://www.openchess.org/noitatsko/programming/<i class="fa fa-external-link-alt"></i></span>  2001-05-25</p>
<p>1. Linux 脚本编写基础<br />
1.1 语法基本介绍<br />
1.1.1 开头<br />
程序必须以下面的行开始（必须方在文件的第一行）：<br />
#!/bin/sh<br />
符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br />
当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br />
要使脚本可执行：<br />
编译 chmod +x filename 这样才能用./filename 来运行<br />
1.1.2 注释<br />
在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。<br />
如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用<br />
及工作原理。<br />
1.1.3 变量<br />
在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量<br />
进行声明。要赋值给一个变量，您可以这样写：<br />
#!/bin/sh<br />
#对变量赋值：<br />
a=“hello world”</p>
<h1 id="现在打印变量a的内容"><a class="markdownIt-Anchor" href="#现在打印变量a的内容"></a> 现在打印变量a的内容：</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;A is:&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>  </span><br></pre></td></tr></table></figure>
<p>有时候变量名很容易与其他文字混淆，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=2  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is the <span class="variable">$numnd</span>&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>这并不会打印出&quot;this is the 2nd&quot;，而仅仅打印&quot;this is the &quot;，因为shell会去搜索变量numnd的值，<br />
但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=2  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is the <span class="variable">$&#123;num&#125;</span>nd&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>这将打印： this is the 2nd<br />
1.1.4 环境变量<br />
由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录<br />
脚本中使用环境变量。<br />
1.1.5 Shell命令和流程控制<br />
在shell脚本中可以使用三类命令：<br />
1)Unix 命令:<br />
虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来<br />
进行文件和文字操作的。<br />
常用命令语法及功能<br />
echo “some text”: 将文字内容打印在屏幕上<br />
ls: 文件列表<br />
wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数<br />
cp sourcefile destfile: 文件拷贝<br />
mv oldname newname : 重命名文件或移动文件<br />
rm file: 删除文件<br />
grep ‘pattern’ file: 在文件内搜索字符串比如：grep ‘searchstring’ file.txt<br />
cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出<br />
每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，<br />
这是两个完全不同的命令<br />
cat file.txt: 输出文件内容到标准输出设备（屏幕）上<br />
file somefile: 得到文件类型<br />
read var: 提示用户输入，并将输入赋值给变量<br />
sort file.txt: 对file.txt文件中的行进行排序<br />
uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq<br />
expr: 进行数学运算Example: add 2 and 3expr 2 “+” 3<br />
find: 搜索文件比如：根据文件名搜索find . -name filename -print<br />
tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile<br />
basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux<br />
dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin<br />
head file: 打印文本文件开头几行<br />
tail file : 打印文本文件末尾几行<br />
sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将<br />
结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。<br />
不要和shell中的通配符相混淆。比如：将linuxfocus 替换为<br />
LinuxFocus ：cat text.file | sed ‘s/linuxfocus/LinuxFocus/’ &gt; newtext.file<br />
awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt | awk -F, <span class="string">&#x27;&#123;print $1 &quot;,&quot; $3 &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用，作为字段分割符，同时打印<br />
第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA<br />
命令输出结果为：Adam Bor, IndiaKerry Miller, USA<br />
2) 概念: 管道, 重定向和 backtick<br />
这些不是系统命令，但是他们真的很重要。<br />
管道 (|) 将一个命令的输出作为另外一个命令的输入。<br />
grep “hello” file.txt | wc -l<br />
在file.txt中搜索包含有”hello”的行并计算其行数。<br />
在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br />
重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。</p>
<blockquote>
<p>写入文件并覆盖旧文件</p>
<blockquote>
<p>加到文件的尾部，保留旧文件内容。<br />
反短斜线<br />
使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br />
命令：<br />
find . -mtime -1 -type f -print<br />
用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您<br />
想将所有查找到的文件打一个包，则可以使用以下脚本：<br />
#!/bin/sh</p>
</blockquote>
</blockquote>
<h1 id="the-ticks-are-backticks-not-normal-quotes"><a class="markdownIt-Anchor" href="#the-ticks-are-backticks-not-normal-quotes"></a> The ticks are backticks (`) not normal quotes ('):</h1>
<p>tar -zcvf lastmod.tar.gz <code>find . -mtime -1 -type f -print</code><br />
3) 流程控制<br />
1.if<br />
“if” 表达式 如果条件为真则执行then后面的部分：<br />
if …; then<br />
…<br />
elif …; then<br />
…<br />
else<br />
…<br />
fi<br />
大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件<br />
是否存在及是否可读等等…<br />
通常用&quot; [ ] &quot;来表示条件测试。注意这里的空格很重要。要确保方括号的空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ -f <span class="string">&quot;somefile&quot;</span> ] ：判断是否是一个文件  </span><br><span class="line">[ -x <span class="string">&quot;/bin/ls&quot;</span> ] ：判断/bin/ls是否存在并有可执行权限  </span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ] ：判断<span class="variable">$var</span>变量是否有值  </span><br><span class="line">[ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> = <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ] ：判断<span class="variable">$a</span>和<span class="variable">$b</span>是否相等  </span><br></pre></td></tr></table></figure>
<p>执行man test可以查看所有测试表达式可以比较和判断的类型。<br />
直接执行以下脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span> = <span class="string">&quot;/bin/bash&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your login shell is the bash (bourne again shell)&quot;</span>  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your login shell is not bash but <span class="variable">$SHELL</span>&quot;</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br></pre></td></tr></table></figure>
<p>变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。<br />
快捷操作符<br />
熟悉C语言的朋友可能会很喜欢下面的表达式：<br />
[ -f “/etc/shadow” ] &amp;&amp; echo “This computer uses shadow passwors”<br />
这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。<br />
您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在<br />
则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是<br />
可用的。这里有个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">mailfolder=/var/spool/mail/james  </span><br><span class="line">[ -r <span class="string">&quot;<span class="variable">$mailfolder</span>&quot;</span> ]<span class="string">&#x27; &#x27;</span>&#123; <span class="built_in">echo</span> <span class="string">&quot;Can not read <span class="variable">$mailfolder</span>&quot;</span> ; <span class="built_in">exit</span> 1; &#125;  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$mailfolder</span> has mail from:&quot;</span>  </span><br><span class="line">grep <span class="string">&quot;^From &quot;</span> <span class="variable">$mailfolder</span>  </span><br></pre></td></tr></table></figure>
<p>该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的&quot;From&quot; 一行。如果不可读<br />
则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：<br />
-打印错误信息<br />
-退出程序<br />
我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。<br />
不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。<br />
2.case<br />
case :表达式可以用来匹配一个给定的字符串，而不是数字。<br />
case … in<br />
…) do something here ;;<br />
esac<br />
让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br />
file lf.gz<br />
这将返回：<br />
lf.gz: gzip compressed data, deflated, original filename,<br />
last modified: Mon Aug 27 23:09:18 2001, os: Unix<br />
我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">ftype=`file <span class="string">&quot;<span class="variable">$1</span>&quot;</span>`  </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ftype</span>&quot;</span> <span class="keyword">in</span>  </span><br><span class="line"><span class="string">&quot;<span class="variable">$1</span>: Zip archive&quot;</span>*)  </span><br><span class="line">unzip <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ;;  </span><br><span class="line"><span class="string">&quot;<span class="variable">$1</span>: gzip compressed&quot;</span>*)  </span><br><span class="line">gunzip <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ;;  </span><br><span class="line"><span class="string">&quot;<span class="variable">$1</span>: bzip2 compressed&quot;</span>*)  </span><br><span class="line">bunzip2 <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ;;  </span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$1</span> can not be uncompressed with smartzip&quot;</span>;;   </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。<br />
也就是说，当我们运行：<br />
smartzip articles.zip<br />
$1 就是字符串 articles.zip</p>
<p>这里要注意的是最后一个*)是必须要写的，意思和default一样。而前面的*)中的*是正则式的一部分。另外&quot;$ftype&quot;没有必要写&quot;&quot;.</p>
<p>case的具体语法如下：</p>
<p>case word in [ pattern [ | pattern ] … ) list ;; ] … esac<br />
case/esac的标准用法大致如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span>  </span><br><span class="line">pattern | sample) <span class="comment"># arg in pattern or sample  </span></span><br><span class="line">;;  </span><br><span class="line">pattern1) <span class="comment"># arg in pattern1  </span></span><br><span class="line">;;  </span><br><span class="line">*) <span class="comment">#default   </span></span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>
<p>arg是您所引入的参数，如果arg内容符合pattern项目的话，那麽便会执行pattern以下的程式码，而该段程式码则以两个分号&quot;;;&quot;做结尾。</p>
<h2 id="可以注意到case及esac是对称的如果记不起来的话把case颠倒过来即可-"><a class="markdownIt-Anchor" href="#可以注意到case及esac是对称的如果记不起来的话把case颠倒过来即可-"></a> 可以注意到&quot;case&quot;及&quot;esac&quot;是对称的，如果记不起来的话，把&quot;case&quot;颠倒过来即可。<br />
-----------------------------------------------------------------------------</h2>
<p>例一 : paranoia</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">start | begin)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start something&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">stop | end)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;stop something&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Ignorant&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行<br />
[foxman@foxman bash]# chmod 755 paranoia<br />
[foxman@foxman bash]# ./paranoia<br />
Ignorant<br />
[foxman@foxman bash]# ./paranoia start<br />
start something<br />
[foxman@foxman bash]# ./paranoia begin<br />
start something<br />
[foxman@foxman bash]# ./paranoia stop<br />
stop something<br />
[foxman@foxman bash]# ./paranoia end<br />
stop something</p>
<h2 id="-"><a class="markdownIt-Anchor" href="#-"></a> -----------------------------------------------------------------------------</h2>
<p>例二 : inetpanel<br />
许多的daemon都会附上一个管理用的Shell Script，像BIND就附上ndc，Apache就附上apachectl。这些管理程式都是用shell<br />
script来写的，以下示一个管理inetd的shell script。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">start | begin | commence)  </span><br><span class="line">/usr/sbin/inetd  </span><br><span class="line">;;  </span><br><span class="line">stop | end | destroy)  </span><br><span class="line">killall inetd  </span><br><span class="line">;;  </span><br><span class="line">restart | again)  </span><br><span class="line">killall -HUP inetd  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: inetpanel [start | begin | commence | stop | end | destory |</span></span><br><span class="line"><span class="string">restart | again]&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>
<h2 id="--2"><a class="markdownIt-Anchor" href="#--2"></a> -----------------------------------------------------------------------------</h2>
<p>例三 : 判断系统<br />
有时候，您所写的Script可能会跨越好几种平台，如Linux、FreeBSD、Solaris等等，而各平台之间，多多少少都有不同之处，有时候需要判断目前正<br />
在那一种平台上执行。此时，我们可以利用uname来找出系统资讯。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">  </span><br><span class="line">SYSTEM=`<span class="built_in">uname</span> -s`  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$SYSTEM</span> <span class="keyword">in</span>  </span><br><span class="line">Linux)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My system is Linux&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do Linux stuff here...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">FreeBSD)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My system is FreeBSD&quot;</span>  <span class="keyword">case</span> word <span class="keyword">in</span> [ pattern [ | pattern ] ... ) list</span><br><span class="line">;; ] ... <span class="keyword">esac</span>  </span><br><span class="line"><span class="keyword">case</span>/esac的标准用法大致如下:  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span>  </span><br><span class="line">pattern | sample) <span class="comment"># arg in pattern or sample  </span></span><br><span class="line">;;  </span><br><span class="line">pattern1) <span class="comment"># arg in pattern1  </span></span><br><span class="line">;;  </span><br><span class="line">*) <span class="comment">#default   </span></span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>
<p>arg是您所引入的参数，如果arg内容符合pattern项目的话，那麽便会执行pattern以下的程式码，而该段程式码则以两个分号&quot;;;&quot;做结尾。</p>
<h2 id="可以注意到case及esac是对称的如果记不起来的话把case颠倒过来即可--2"><a class="markdownIt-Anchor" href="#可以注意到case及esac是对称的如果记不起来的话把case颠倒过来即可--2"></a> 可以注意到&quot;case&quot;及&quot;esac&quot;是对称的，如果记不起来的话，把&quot;case&quot;颠倒过来即可。<br />
-----------------------------------------------------------------------------</h2>
<p>例一 : paranoia</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">start | begin)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start something&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">stop | end)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;stop something&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Ignorant&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行<br />
[foxman@foxman bash]# chmod 755 paranoia<br />
[foxman@foxman bash]# ./paranoia<br />
Ignorant<br />
[foxman@foxman bash]# ./paranoia start<br />
start something<br />
[foxman@foxman bash]# ./paranoia begin<br />
start something<br />
[foxman@foxman bash]# ./paranoia stop<br />
stop something<br />
[foxman@foxman bash]# ./paranoia end<br />
stop something</p>
<h2 id="--3"><a class="markdownIt-Anchor" href="#--3"></a> -----------------------------------------------------------------------------</h2>
<p>例二 : inetpanel<br />
许多的daemon都会附上一个管理用的Shell Script，像BIND就附上ndc，Apache就附上apachectl。这些管理程式都是用shell<br />
script来写的，以下示一个管理inetd的shell script。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">start | begin | commence)  </span><br><span class="line">/usr/sbin/inetd  </span><br><span class="line">;;  </span><br><span class="line">stop | end | destroy)  </span><br><span class="line">killall inetd  </span><br><span class="line">;;  </span><br><span class="line">restart | again)  </span><br><span class="line">killall -HUP inetd  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: inetpanel [start | begin | commence | stop | end | destory |</span></span><br><span class="line"><span class="string">restart | again]&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>
<h2 id="--4"><a class="markdownIt-Anchor" href="#--4"></a> -----------------------------------------------------------------------------</h2>
<p>例三 : 判断系统<br />
有时候，您所写的Script可能会跨越好几种平台，如Linux、FreeBSD、Solaris等等，而各平台之间，多多少少都有不同之处，有时候需要判断目前正<br />
在那一种平台上执行。此时，我们可以利用uname来找出系统资讯。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh  </span></span><br><span class="line">  </span><br><span class="line">SYSTEM=`<span class="built_in">uname</span> -s`  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$SYSTEM</span> <span class="keyword">in</span>  </span><br><span class="line">Linux)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My system is Linux&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do Linux stuff here...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">FreeBSD)  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My system is FreeBSD&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do FreeBSD stuff here...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Unknown system : <span class="variable">$SYSTEM</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t what to do...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do FreeBSD stuff here...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line">*)   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Unknown system : <span class="variable">$SYSTEM</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t what to do...&quot;</span>  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>
<p>3. selsect<br />
select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> var <span class="keyword">in</span> ... ; <span class="keyword">do</span>  </span><br><span class="line"><span class="built_in">break</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line">.... now <span class="variable">$var</span> can be used ....  </span><br></pre></td></tr></table></figure>
<p>下面是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your favourite OS?&quot;</span>  </span><br><span class="line"><span class="keyword">select</span> var <span class="keyword">in</span> <span class="string">&quot;Linux&quot;</span> <span class="string">&quot;Gnu Hurd&quot;</span> <span class="string">&quot;Free BSD&quot;</span> <span class="string">&quot;Other&quot;</span>; <span class="keyword">do</span>  </span><br><span class="line"><span class="built_in">break</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You have selected <span class="variable">$var</span>&quot;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是该脚本运行的结果：<br />
What is your favourite OS?</p>
<ol>
<li>Linux</li>
<li>Gnu Hurd</li>
<li>Free BSD</li>
<li>Other<br />
#? 1<br />
You have selected Linux<br />
4.loop<br />
loop表达式：<br />
while …; do<br />
…<br />
done<br />
while-loop 将运行直到表达式测试为真。will run while the expression that we test for is<br />
true.<br />
关键字&quot;break&quot; 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。</li>
</ol>
<p>for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br />
for var in …; do<br />
…<br />
done<br />
在下面的例子中，将分别打印ABC到屏幕上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> A B C ; <span class="keyword">do</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var is <span class="variable">$var</span>&quot;</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br></pre></td></tr></table></figure>
<p>下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh  </span></span><br><span class="line"><span class="comment"># list a content summary of a number of RPM packages  </span></span><br><span class="line"><span class="comment"># USAGE: showrpm rpmfile1 rpmfile2 ...  </span></span><br><span class="line"><span class="comment"># EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm  </span></span><br><span class="line"><span class="keyword">for</span> rpmpackage <span class="keyword">in</span> $*; <span class="keyword">do</span>  </span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$rpmpackage</span>&quot;</span> ];<span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=============== <span class="variable">$rpmpackage</span> ==============&quot;</span>  </span><br><span class="line">rpm -qi -p <span class="variable">$rpmpackage</span>  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ERROR: cannot read file <span class="variable">$rpmpackage</span>&quot;</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br></pre></td></tr></table></figure>
<p>这里出现了第二个特殊的变量$<em>，该变量包含了所有输入的命令行参数值。<br />
如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br />
此时 $</em> 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.</p>
<p>5. 引号<br />
在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符<br />
（比如*）替换成合适的文件名，它变量替换成变量值。为了防 止程序作这种替换，您可以使用<br />
引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。<br />
1.2 编译SHELL脚本<br />
#ch#!/bin/sh mod +x filename<br />
cho *.jpg ∪缓螅梢酝ü淙耄?./filename 来执行您的脚本。<br />
这将打印出&quot;mail.jpg tux.jpg&quot;的结果。<br />
引号 (单引号和双引号) 将防止这种通配符扩展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*.jpg&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;*.jpg&#x27;</span>  </span><br></pre></td></tr></table></figure>
<p>这将打印&quot;*.jpg&quot; 两次。<br />
单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$SHELL&#x27;</span>  </span><br></pre></td></tr></table></figure>
<p>运行结果为：<br />
/bin/bash<br />
/bin/bash<br />
$SHELL<br />
最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> *.jpg  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span>  </span><br></pre></td></tr></table></figure>
<p>这将输出：<br />
*.jpg<br />
$SHELL<br />
6. Here documents<br />
当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译）<br />
一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents<br />
就不必用echo函数一行行输出。 一个 “Here document” 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串<br />
还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且<br />
使用here documents打印帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="comment"># we have less than 3 arguments. Print the help text:  </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 3 ] ; <span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">cat</span> &lt;  </span><br><span class="line">ren -- renames a number of files using sed regular expressions  </span><br><span class="line">USAGE: ren <span class="string">&#x27;regexp&#x27;</span> <span class="string">&#x27;replacement&#x27;</span> files...  </span><br><span class="line">EXAMPLE: rename all *.HTM files <span class="keyword">in</span> *.html:  </span><br><span class="line">ren <span class="string">&#x27;HTM$&#x27;</span> <span class="string">&#x27;html&#x27;</span> *.HTM  </span><br><span class="line">HELP  </span><br><span class="line"><span class="built_in">exit</span> 0  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">OLD=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>  </span><br><span class="line">NEW=<span class="string">&quot;<span class="variable">$2</span>&quot;</span>  </span><br><span class="line"><span class="comment"># The shift command removes one argument from the list of  </span></span><br><span class="line"><span class="comment"># command line arguments.  </span></span><br><span class="line"><span class="built_in">shift</span>  </span><br><span class="line"><span class="built_in">shift</span>  </span><br><span class="line"><span class="comment"># $* contains now all the files:  </span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $*; <span class="keyword">do</span>  </span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] ; <span class="keyword">then</span>  </span><br><span class="line">newfile=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> | sed <span class="string">&quot;s/<span class="variable">$&#123;OLD&#125;</span>/<span class="variable">$&#123;NEW&#125;</span>/g&quot;</span>`  </span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$newfile</span>&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ERROR: <span class="variable">$newfile</span> exists already&quot;</span>  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;renaming <span class="variable">$file</span> to <span class="variable">$newfile</span> ...&quot;</span>  </span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$newfile</span>&quot;</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br></pre></td></tr></table></figure>
<p>这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是<br />
否小于3个 (特殊变量$# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递<br />
给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等<br />
于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我<br />
们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参<br />
数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。<br />
接着我 们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后<br />
将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目 的：得到了旧文件名和新<br />
文件名。然后使用mv命令进行重命名。</p>
<p>4)函数<br />
如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，<br />
并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionname</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment"># inside the body $1 is the first argument given to the function  </span></span><br><span class="line"><span class="comment"># $2 the second ...  </span></span><br><span class="line">body  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>您需要在每个程序的开始对函数进行声明。<br />
下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。<br />
这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh  </span></span><br><span class="line"><span class="comment"># vim: set sw=4 ts=4 et:  </span></span><br><span class="line"><span class="function"><span class="title">help</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">cat</span> &lt;  </span><br><span class="line">xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole  </span><br><span class="line">USAGE: xtitlebar [-h] <span class="string">&quot;string_for_titelbar&quot;</span>  </span><br><span class="line">OPTIONS: -h <span class="built_in">help</span> text  </span><br><span class="line">EXAMPLE: xtitlebar <span class="string">&quot;cvs&quot;</span>  </span><br><span class="line">HELP  </span><br><span class="line"><span class="built_in">exit</span> 0  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment"># in case of error or if -h is given we call the function help:  </span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; <span class="built_in">help</span>  </span><br><span class="line">[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;-h&quot;</span> ] &amp;&amp; <span class="built_in">help</span>  </span><br><span class="line"><span class="comment"># send the escape sequence to change the xterm titelbar:  </span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;33]0;<span class="variable">$107</span>&quot;</span>  </span><br><span class="line"><span class="comment">#  </span></span><br></pre></td></tr></table></figure>
<p>在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br />
命令行参数<br />
我们已经见过$* 和 $1, $2 … $9 等特殊变量，这些特殊变量包含了用户从命令<br />
行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的<br />
参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的<br />
自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (<br />
比如文件名)。<br />
有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="function"><span class="title">help</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">cat</span> &lt;  </span><br><span class="line">This is a generic <span class="built_in">command</span> line parser demo.  </span><br><span class="line">USAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2  </span><br><span class="line">HELP  </span><br><span class="line"><span class="built_in">exit</span> 0  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span>  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">-h) <span class="built_in">help</span>;<span class="built_in">shift</span> 1;; <span class="comment"># function help is called   </span></span><br><span class="line">-f) opt_f=1;<span class="built_in">shift</span> 1;; <span class="comment"># variable opt_f is set   </span></span><br><span class="line">-l) opt_l=<span class="variable">$2</span>;<span class="built_in">shift</span> 2;; <span class="comment"># -l takes an argument -&gt; shift by 2   </span></span><br><span class="line">\--) <span class="built_in">shift</span>;<span class="built_in">break</span>;; <span class="comment"># end of options  </span></span><br><span class="line">-*) <span class="built_in">echo</span> <span class="string">&quot;error: no such option <span class="variable">$1</span>. -h for help&quot;</span>;<span class="built_in">exit</span> 1;;   </span><br><span class="line">*) <span class="built_in">break</span>;;   </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;opt_f is <span class="variable">$opt_f</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;opt_l is <span class="variable">$opt_l</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;first arg is <span class="variable">$1</span>&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2nd arg is <span class="variable">$2</span>&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>您可以这样运行该脚本：<br />
cmdparser -l hello -f – -somefile1 somefile2<br />
返回的结果是：<br />
opt_f is 1<br />
opt_l is hello<br />
first arg is -somefile1<br />
2nd arg is somefile2<br />
这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数<br />
与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，<br />
首先输入的应该是包含减号的参数.<br />
第2部分 实例<br />
现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（<span class="exturl" data-url="aHR0cDovL2ZyYW1ld29yay5zaA==">framework.sh<i class="fa fa-external-link-alt"></i></span>），该脚本包含了大多数脚本都需要的框<br />
架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br />
cp <span class="exturl" data-url="aHR0cDovL2ZyYW1ld29yay5zaA==">framework.sh<i class="fa fa-external-link-alt"></i></span> myscript<br />
然后再插入自己的函数。<br />
让我们再看两个例子：<br />
二进制到十进制的转换<br />
脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="comment"># vim: set sw=4 ts=4 et:  </span></span><br><span class="line"><span class="function"><span class="title">help</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">cat</span> &lt;  </span><br><span class="line">b2h -- convert binary to decimal  </span><br><span class="line">USAGE: b2h [-h] binarynum  </span><br><span class="line">OPTIONS: -h <span class="built_in">help</span> text  </span><br><span class="line">EXAMPLE: b2h 111010  </span><br><span class="line">will <span class="built_in">return</span> 58  </span><br><span class="line">HELP  </span><br><span class="line"><span class="built_in">exit</span> 0  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">error</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment"># print an error and exit  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>  </span><br><span class="line"><span class="built_in">exit</span> 1  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">lastchar</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment"># return the last character of a string in $rval  </span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="comment"># empty string  </span></span><br><span class="line">rval=<span class="string">&quot;&quot;</span>  </span><br><span class="line"><span class="built_in">return</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="comment"># wc puts some space behind the output this is why we need sed:  </span></span><br><span class="line">numofchar=`<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">wc</span> -c | sed <span class="string">&#x27;s/ //g&#x27;</span> `  </span><br><span class="line"><span class="comment"># now cut out the last char  </span></span><br><span class="line">rval=`<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">cut</span> -b <span class="variable">$numofchar</span>`  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">chop</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment"># remove the last character in string and return it in $rval  </span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="comment"># empty string  </span></span><br><span class="line">rval=<span class="string">&quot;&quot;</span>  </span><br><span class="line"><span class="built_in">return</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="comment"># wc puts some space behind the output this is why we need sed:  </span></span><br><span class="line">numofchar=`<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">wc</span> -c | sed <span class="string">&#x27;s/ //g&#x27;</span> `  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$numofchar</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="comment"># only one char in string  </span></span><br><span class="line">rval=<span class="string">&quot;&quot;</span>  </span><br><span class="line"><span class="built_in">return</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">numofcharminus1=`<span class="built_in">expr</span> <span class="variable">$numofchar</span> <span class="string">&quot;-&quot;</span> 1`  </span><br><span class="line"><span class="comment"># now cut all but the last char:  </span></span><br><span class="line">rval=`<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">cut</span> -b 0-<span class="variable">$&#123;numofcharminus1&#125;</span>`  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span>  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">-h) <span class="built_in">help</span>;<span class="built_in">shift</span> 1;; <span class="comment"># function help is called   </span></span><br><span class="line">\--) <span class="built_in">shift</span>;<span class="built_in">break</span>;; <span class="comment"># end of options  </span></span><br><span class="line">-*) error <span class="string">&quot;error: no such option <span class="variable">$1</span>. -h for help&quot;</span>;;   </span><br><span class="line">*) <span class="built_in">break</span>;;   </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line"><span class="comment"># The main program  </span></span><br><span class="line"><span class="built_in">sum</span>=0  </span><br><span class="line">weight=1  </span><br><span class="line"><span class="comment"># one arg must be given:  </span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; <span class="built_in">help</span>  </span><br><span class="line">binnum=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>  </span><br><span class="line">binnumorig=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>  </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$binnum</span>&quot;</span> ]; <span class="keyword">do</span>  </span><br><span class="line">lastchar <span class="string">&quot;<span class="variable">$binnum</span>&quot;</span>  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$rval</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">sum</span>=`<span class="built_in">expr</span> <span class="string">&quot;<span class="variable">$weight</span>&quot;</span> <span class="string">&quot;+&quot;</span> <span class="string">&quot;<span class="variable">$sum</span>&quot;</span>`  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="comment"># remove the last position in $binnum  </span></span><br><span class="line">chop <span class="string">&quot;<span class="variable">$binnum</span>&quot;</span>  </span><br><span class="line">binnum=<span class="string">&quot;<span class="variable">$rval</span>&quot;</span>  </span><br><span class="line">weight=`<span class="built_in">expr</span> <span class="string">&quot;<span class="variable">$weight</span>&quot;</span> <span class="string">&quot;*&quot;</span> 2`  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;binary <span class="variable">$binnumorig</span> is decimal <span class="variable">$sum</span>&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,…)，比如二进制&quot;10&quot;可<br />
以这样转换成十进制：<br />
0 * 1 + 1 * 2 = 2<br />
为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，<br />
然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br />
文件循环程序<br />
或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月<br />
以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的 脚本rotatefile<br />
可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，<br />
而对于outmail.1就变成了outmail.2 等等等等…</p>
<pre class="highlight"><code class="bash"><span class="meta">#!/bin/sh  </span>
<span class="comment"># vim: set sw=4 ts=4 et:  </span>
ver=<span class="string">&quot;0.1&quot;</span>  
<span class="function"><span class="title">help</span></span>()  
&#123;  
<span class="built_in">cat</span> &lt;  
rotatefile -- rotate the file name  
USAGE: rotatefile [-h] filename  
OPTIONS: -h <span class="built_in">help</span> text  
EXAMPLE: rotatefile out  
This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1  
and create an empty out-file  
The max number is 10  
version <span class="variable">$ver</span>  
HELP  
<span class="built_in">exit</span> 0  
&#125;  
<span class="function"><span class="title">error</span></span>()  
&#123;  
<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>  
<span class="built_in">exit</span> 1  
&#125;  
<span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span>  
<span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  
-h) <span class="built_in">help</span>;<span class="built_in">shift</span> 1;;   
\--) <span class="built_in">break</span>;;  
-*) <span class="built_in">echo</span> <span class="string">&quot;error: no such option <span class="variable">$1</span>. -h for help&quot;</span>;<span class="built_in">exit</span> 1;;   
*) <span class="built_in">break</span>;;   
<span class="keyword">esac</span>  
<span class="keyword">done</span>  
<span class="comment"># input check:  </span>
<span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] ; <span class="keyword">then</span>  
error <span class="string">&quot;ERROR: you must specify a file, use -h for help&quot;</span>  
<span class="keyword">fi</span>  
filen=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>  
<span class="comment"># rename any .1 , .2 etc file:  </span>
<span class="keyword">for</span> n <span class="keyword">in</span> 9 8 7 6 5 4 3 2 1; <span class="keyword">do</span>  
<span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$filen</span>.<span class="variable">$n</span>&quot;</span> ]; <span class="keyword">then</span>  
p=`<span class="built_in">expr</span> <span class="variable">$n</span> + 1`  
<span class="built_in">echo</span> <span class="string">&quot;mv <span class="variable">$filen</span>.<span class="variable">$n</span> <span class="variable">$filen</span>.<span class="variable">$p</span>&quot;</span>  
<span class="built_in">mv</span> <span class="variable">$filen</span>.<span class="variable">$n</span> <span class="variable">$filen</span>.<span class="variable">$p</span>  
<span class="keyword">fi</span>  
<span class="keyword">done</span>  
<span class="comment"># rename the original file:  </span>
<span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$filen</span>&quot;</span> ]; <span class="keyword">then</span>  
<span class="built_in">echo</span> <span class="string">&quot;mv <span class="variable">$filen</span> <span class="variable">$filen</span>.1&quot;</span>  
<span class="built_in">mv</span> <span class="variable">$filen</span> <span class="variable">$filen</span>.1  
<span class="keyword">fi</span>  
<span class="built_in">echo</span> <span class="built_in">touch</span> <span class="variable">$filen</span>  
<span class="built_in">touch</span> <span class="variable">$filen</span>  

</code></pre>
<p>这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名<br />
为文件1同时建立一个与原始文件同名的空文件。<br />
调试<br />
最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的<br />
原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br />
shell也有一个真实的调试模式。如果在脚本&quot;strangescript&quot; 中有错误，您可以这样来进行调试：<br />
sh -x strangescript<br />
这将执行该脚本并显示所有变量的值。<br />
shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br />
sh -n your_script<br />
这将返回所有语法错误</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chillyc.info/2009/10/27/4734104/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/icon.svg">
      <meta itemprop="name" content="帐前卒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帐前卒专栏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 帐前卒专栏">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2009/10/27/4734104/" class="post-title-link" itemprop="url">C语言中static使用方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2009-10-27 16:22:00" itemprop="dateCreated datePublished" datetime="2009-10-27T16:22:00+08:00">2009-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 12:41:45" itemprop="dateModified" datetime="2023-10-05T12:41:45+08:00">2023-10-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载自 <a target="_blank" rel="noopener" href="http://tech.ddvip.com/2009-02/1234594734108774.html"> http://tech.ddvip.com/2009-02/1234594734108774.html<br />
</a></p>
<p>一、c程序存储空间布局</p>
<p>C程序一直由下列部分组成：</p>
<p>1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；</p>
<p>2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。</p>
<p>3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。</p>
<p>4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。</p>
<p>5）堆——动态存储分。</p>
<p>` |-----------|</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
</tr>
<tr>
<td>-----------</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>/</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>-----------</td>
</tr>
<tr>
<td>堆</td>
</tr>
<tr>
<td>-----------</td>
</tr>
<tr>
<td>未初始化</td>
</tr>
<tr>
<td>-----------</td>
</tr>
<tr>
<td>初始化</td>
</tr>
<tr>
<td>-----------</td>
</tr>
<tr>
<td>正文段</td>
</tr>
<tr>
<td>-----------</td>
</tr>
</tbody>
</table>
<p>二、 面向过程程序设计中的static</p>
<p>1. 全局静态变量</p>
<p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p>
<p>1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>
<p>2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</p>
<p>3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</p>
<p>定义全局静态变量的好处：</p>
<p>&lt;1&gt;不会被其他文件所访问，修改</p>
<p>&lt;2&gt;其他文件中可以使用相同名字的变量，不会发生冲突。</p>
<p>2. 局部静态变量</p>
<p>在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。</p>
<p>1）内存中的位置：静态存储区</p>
<p>2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</p>
<p>3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>
<p>注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是<br />
仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p>
<p>当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。</p>
<p>3. 静态函数</p>
<p>在函数的返回类型前加上关键字static，函数就被定义成为静态函数。</p>
<p>函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>定义静态函数的好处：</p>
<p>&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突</p>
<p>&lt;2&gt; 静态函数不能被其他文件所用。</p>
<p>存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。</p>
<p>auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出该程序块时撤销。</p>
<p>关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期（static storage<br />
duration），或静态范围（static<br />
extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。</p>
<p>扩展分析:</p>
<p>术语static有着不寻常的历史.起初，在C中引入关键字static是为了表示退出一个块后仍然存在的局部变量。随后，static<br />
C中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static关键字来表示这第二种含义。最后，</p>
<p>C++重用了这个关键字，并赋予它与前面不同的第三种含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数(与Java中此关键字的含义相同)。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/33/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><span class="space">&hellip;</span><a class="page-number" href="/page/80/">80</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/35/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">帐前卒</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">1.6m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">24:17</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/comments.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/motion.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/next-boot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/bookmark.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/third-party/search/local-search.min.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha256-3574TpfThVfeAhg+I4+N39EJiLN3QUkuEsMVe8hWAR4=" crossorigin="anonymous">


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"chilly/blog_comments","issue_term":"url","theme":"github-dark"}</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.18.1/source/js/third-party/comments/utterances.min.js"></script>

</body>
</html>
